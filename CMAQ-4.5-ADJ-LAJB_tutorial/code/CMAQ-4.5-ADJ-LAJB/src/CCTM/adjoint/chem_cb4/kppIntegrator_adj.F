
C     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     
C     Numerical Integrator (Time-Stepping) File
C     
C     Generated by KPP-2.1 symbolic chemistry Kinetics PreProcessor
C     (http://www.cs.vt.edu/~asandu/Software/KPP)
C     KPP is distributed under GPL, the general public licence
C     (http://www.gnu.org/copyleft/gpl.html)
C     (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
C     (C) 1997-2005, A. Sandu, Michigan Tech, Virginia Tech
C     With important contributions from:
C     M. Damian, Villanova University, USA
C     R. Sander, Max-Planck Institute for Chemistry, Mainz, Germany
C     
C     File                 : KPP_Integrator.f90
C     Time                 : Tue Apr 18 15:57:11 2006
C     Working directory    : /home/amir/Desktop/KPP/kpp-2.1
C     Equation file        : CMAQ_CB4.kpp
C     Output root filename : CMAQ_CB4
C     
C     September 9th 2013, Lucas A. J. Bastien: I corrected non-standard
C     complying code: using sequence allocation with array pointers when
C     the corresponding dummy argument is not assumed-shaped. It happens
C     when using a single element of an array pointer as an argument for
C     an non-assumed-shaped array dummy argument in a subroutine
C     call. Passing array sections instead of single elements fixed the
C     problem. There exists other possible solutions (make the array
C     ALLOCATABLE instead of POINTER; or declare the summy argument as
C     assumed-shaped -- an explicit interface must be visible to the
C     caller in that case). I also changed the declaration of ISTATUS
C     and RSTATUS in subroutine RosenbrockADJ from ISTATUS(10) to
C     ISTATUS(20) and from RSTATUS(10) to RSTATUS(20) to fix "index out
C     of bound" errors.
C
C     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


      MODULE KPP_INTEGRATOR_ADJ

      USE KPP_PRECISION
      USE KPP_PARS
      USE KPP_FUNCTION
      USE KPP_GLOB
      USE KPP_LINALG
      USE KPP_JACOBIAN
      USE KPP_HESSIAN
      USE KPP_UTIL
      
      IMPLICIT NONE
      PUBLIC
      SAVE
C~~~  >  Statistics on the work performed by the Rosenbrock method
      INTEGER :: Nfun,Njac,Nstp,Nacc,Nrej,Ndec,Nsol,Nsng
      INTEGER, PARAMETER :: ifun=11, ijac=12, istp=13, iacc=14,   
     &     irej=15, idec=16, isol=17, isng=18,   
     &     itexit=11,ihexit=12
C~~~  >  Types of Adjoints Implemented
      INTEGER, PARAMETER :: Adj_none = 1, Adj_discrete = 2,       
     &     Adj_continuous = 3, Adj_simple_continuous = 4
      REAL(kind=dp), PARAMETER :: ZERO = 0.0d0, ONE  = 1.0d0 
C~~~  >  Checkpoints in memory
      INTEGER, PARAMETER :: bufsize = 1500
      INTEGER :: stack_ptr = 0  ! last written entry
      REAL(kind=dp), DIMENSION(:), POINTER :: buf_H, buf_T
      REAL(kind=dp), DIMENSION(:,:), POINTER :: buf_Y, buf_K, buf_J
      REAL(kind=dp), DIMENSION(:,:), POINTER :: buf_dY, buf_d2Y

      CONTAINS                  ! Functions in the module KPP_Integrator


C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE INTEGRATE_ADJ( NADJ, YU, LamU, RKI, CHEMSTEP, ATOL, RTOL,  
     &     ICNTRL_U, RCNTRL_U, ISTATUS_U, RSTATUS_U )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      IMPLICIT NONE        
      
C~~~  > Y - Concentrations
      REAL(kind=dp)  :: Y(KPPNSP)
C~~~  > NADJ - No. of cost functionals for which adjoints
C     are evaluated simultaneously
C     If single cost functional is considered (like in
C     most applications) simply set NADJ = 1      
      INTEGER NADJ
C~~~  > Lambda - Sensitivities of concentrations
C     Note: Lambda (1:KPPNSP,j) contains sensitivities of
C     the j-th cost functional w.r.t. Y(1:KPPNSP), j=1...NADJ
      REAL(kind=dp)  :: Lambda(KPPNSP,NADJ)
      REAL(kind=dp)  :: TIN     ! TIN  - Start Time
      REAL(kind=dp)  :: TOUT    ! TOUT - End Time
C~~~  > Optional input parameters and statistics
      INTEGER,  INTENT(IN),  OPTIONAL :: ICNTRL_U(20)
      REAL(kind=dp), INTENT(IN),  OPTIONAL :: RCNTRL_U(20)
      INTEGER,  INTENT(OUT), OPTIONAL :: ISTATUS_U(20)
      REAL(kind=dp), INTENT(OUT), OPTIONAL :: RSTATUS_U(20)

      INTEGER, SAVE :: N_stp, N_acc, N_rej, N_sng, IERR
      INTEGER  :: i
      REAL(kind=dp) :: RCNTRL(20), RSTATUS(20)
      INTEGER  :: ICNTRL(20), ISTATUS(20)
      REAL(kind=dp) :: YU(KPPNSP), LamU(KPPNSP), RKI(KPPNRCT), CHEMSTEP
      REAL(kind=dp) :: ATOL(KPPNSP), RTOL(KPPNSP)


      ICNTRL(1:20)  = 0
      RCNTRL(1:20)  = 0.0_dp
      ISTATUS(1:20) = 0
      RSTATUS(1:20) = 0.0_dp
      
      
      ICNTRL(1) = 1             ! 0 = non-autonomous, 1 = autonomous
C     ICNTRL(2) = 1       ! 0 = scalar, 1 = vector tolerances
C     RCNTRL(3) = STEPMIN ! starting step
      ICNTRL(4) = 1             ! choice of the method for forward integration
C     ICNTRL(5) = 2       ! 1=none, 2=discrete, 3=full continuous, 4=simplified continuous adjoint
C     ICNTRL(6) = 1       ! choice of the method for continuous adjoint

C     Tighter tolerances, especially atol, are needed for the full continuous adjoint
C     (Atol on sensitivities is different than on concentrations)
C     CADJ_ATOL(1:KPPNSP) = 1.0d-5
C     CADJ_RTOL(1:KPPNSP) = 1.0d-4
      
                                ! if optional parameters are given, and if they are >=0, then they overwrite default settings
      IF (PRESENT(ICNTRL_U)) THEN
         WHERE(ICNTRL_U(:) >= 0) ICNTRL(1:20) = ICNTRL_U(:)
         END IF
         IF (PRESENT(RCNTRL_U)) THEN
            WHERE(RCNTRL_U(:) >= 0) RCNTRL(1:20) = RCNTRL_U(:)
            END IF
            
            TIN = 0.0d0
            TOUT = 0.0d0+CHEMSTEP
            
            ATOL(:)=1.0d-8      !15 
            RTOL(:)=1.0d-3      !5 
            icntrl(4)=5
            rcntrl(3)=1.0d0

            CALL Shuffle_user2kpp ( YU, Y )
            CALL Shuffle_user2kpp ( LamU, Lambda )
            
            CALL RosenbrockADJ(Y, NADJ, Lambda,           
     &           TIN,TOUT,                               
     &           ATOL,RTOL,                              
     &           RCNTRL,ICNTRL,RSTATUS,ISTATUS,IERR,RKI)
            
            CALL Shuffle_kpp2user ( Y, YU )
            CALL Shuffle_kpp2user ( Lambda, LamU )
            
            
C     N_stp = N_stp + ICNTRL(istp)
C     N_acc = N_acc + ICNTRL(iacc)
C     N_rej = N_rej + ICNTRL(irej)
C     N_sng = N_sng + ICNTRL(isng)
C     PRINT*,'Step=',N_stp,' Acc=',N_acc,' Rej=',N_rej,  
C     ' Singular=',N_sng

            IF (IERR < 0) THEN
               print *,'RosenbrockADJ: Unsucessful step at T=',  
     &              TIN,' (IERR=',IERR,')'
            ENDIF
            
            STEPMIN = RCNTRL(ihexit)
                                ! if optional parameters are given for output 
                                !         copy to them to return information
            IF (PRESENT(ISTATUS_U)) ISTATUS_U(:) = ISTATUS(1:20)
            IF (PRESENT(RSTATUS_U)) RSTATUS_U(:) = RSTATUS(1:20)
            
            END SUBROUTINE INTEGRATE_ADJ
      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_AllocateDBuffers( S )
C~~~  >  Allocate buffer space for discrete adjoint
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      INTEGER :: i, S
      
      ALLOCATE( buf_H(bufsize), STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed allocation of buffer H'; STOP
      END IF   
      ALLOCATE( buf_T(bufsize), STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed allocation of buffer T'; STOP
      END IF   
      ALLOCATE( buf_Y(KPPNSP*S,bufsize), STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed allocation of buffer Y'; STOP
      END IF   
      ALLOCATE( buf_K(KPPNSP*S,bufsize), STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed allocation of buffer K'; STOP
      END IF   
      ALLOCATE( buf_J(LU_NONZERO,bufsize), STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed allocation of buffer J'; STOP
      END IF   
      
      END SUBROUTINE ros_AllocateDBuffers


C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_FreeDBuffers
C~~~  >  Dallocate buffer space for discrete adjoint
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      INTEGER :: i, S
      
      DEALLOCATE( buf_H, STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed deallocation of buffer H'; STOP
      END IF   
      DEALLOCATE( buf_T, STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed deallocation of buffer T'; STOP
      END IF   
      DEALLOCATE( buf_Y, STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed deallocation of buffer Y'; STOP
      END IF   
      DEALLOCATE( buf_K, STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed deallocation of buffer K'; STOP
      END IF   
      DEALLOCATE( buf_J, STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed deallocation of buffer J'; STOP
      END IF   
      
      END SUBROUTINE ros_FreeDBuffers


C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_AllocateCBuffers
C~~~  >  Allocate buffer space for continuous adjoint
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      INTEGER :: i, S
      
      ALLOCATE( buf_H(bufsize), STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed allocation of buffer H'; STOP
      END IF   
      ALLOCATE( buf_T(bufsize), STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed allocation of buffer T'; STOP
      END IF   
      ALLOCATE( buf_Y(KPPNSP,bufsize), STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed allocation of buffer Y'; STOP
      END IF   
      ALLOCATE( buf_dY(KPPNSP,bufsize), STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed allocation of buffer dY'; STOP
      END IF   
      ALLOCATE( buf_d2Y(KPPNSP,bufsize), STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed allocation of buffer d2Y'; STOP
      END IF   
      
      END SUBROUTINE ros_AllocateCBuffers


C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_FreeCBuffers
C~~~  >  Dallocate buffer space for continuous adjoint
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      INTEGER :: i, S
      
      DEALLOCATE( buf_H, STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed deallocation of buffer H'; STOP
      END IF   
      DEALLOCATE( buf_T, STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed deallocation of buffer T'; STOP
      END IF   
      DEALLOCATE( buf_Y, STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed deallocation of buffer Y'; STOP
      END IF   
      DEALLOCATE( buf_dY, STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed deallocation of buffer dY'; STOP
      END IF   
      DEALLOCATE( buf_d2Y, STAT=i )
      IF (i/=0) THEN
         PRINT*,'Failed deallocation of buffer d2Y'; STOP
      END IF   
      
      END SUBROUTINE ros_FreeCBuffers

C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_DPush( S, T, H, Ystage, K ) !, Jcb )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C~~~  > Saves the next trajectory snapshot for discrete adjoints
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      INTEGER :: S              ! no of stages
      REAL(kind=dp) :: T, H, Ystage(KPPNSP*S), K(KPPNSP*S) !, Jcb(LU_NONZERO)
      
      stack_ptr = stack_ptr + 1
      IF ( stack_ptr > bufsize ) THEN
         PRINT*,'Push failed: buffer overflow'
         STOP
      END IF  
      buf_H( stack_ptr ) = H
      buf_T( stack_ptr ) = T
      CALL WCOPY(KPPNSP*S,Ystage,1,buf_Y(1:KPPNSP*S,stack_ptr),1)
      CALL WCOPY(KPPNSP*S,K,1,buf_K(1:KPPNSP*S,stack_ptr),1)
                                !CALL WCOPY(LU_NONZERO,Jcb,1,buf_J(1,stack_ptr),1)
      
      END SUBROUTINE ros_DPush
      
      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_DPop( S, T, H, Ystage, K ) !, Jcb )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C~~~  > Retrieves the next trajectory snapshot for discrete adjoints
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      INTEGER :: S              ! no of stages
      REAL(kind=dp) :: T, H, Ystage(KPPNSP*S), K(KPPNSP*S) ! , Jcb(LU_NONZERO)
      
      IF ( stack_ptr <= 0 ) THEN
         PRINT*,'Pop failed: empty buffer'
         STOP
      END IF  
      H = buf_H( stack_ptr )
      T = buf_T( stack_ptr )
      CALL WCOPY(KPPNSP*S,buf_Y(1:KPPNSP*S,stack_ptr),1,Ystage,1)
      CALL WCOPY(KPPNSP*S,buf_K(1:KPPNSP*S,stack_ptr),1,K,1)
                                !CALL WCOPY(LU_NONZERO,buf_J(1,stack_ptr),1,Jcb,1)

      stack_ptr = stack_ptr - 1
      
      END SUBROUTINE ros_DPop
      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_CPush( T, H, Y, dY, d2Y )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C~~~  > Saves the next trajectory snapshot for discrete adjoints
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      INTEGER :: S              ! no of stages
      REAL(kind=dp) :: T, H, Y(KPPNSP), dY(KPPNSP), d2Y(KPPNSP)
      
      stack_ptr = stack_ptr + 1
      IF ( stack_ptr > bufsize ) THEN
         PRINT*,'Push failed: buffer overflow'
         STOP
      END IF  
      buf_H( stack_ptr ) = H
      buf_T( stack_ptr ) = T
      CALL WCOPY(KPPNSP,Y,1,buf_Y(1:KPPNSP,stack_ptr),1)
      CALL WCOPY(KPPNSP,dY,1,buf_dY(1:KPPNSP,stack_ptr),1)
      CALL WCOPY(KPPNSP,d2Y,1,buf_d2Y(1:KPPNSP,stack_ptr),1)
      
      END SUBROUTINE ros_CPush
      
      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_CPop( T, H, Y, dY, d2Y )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C~~~  > Retrieves the next trajectory snapshot for discrete adjoints
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      INTEGER :: S              ! no of stages
      REAL(kind=dp) :: T, H, Y(KPPNSP), dY(KPPNSP), d2Y(KPPNSP)
      
      IF ( stack_ptr <= 0 ) THEN
         PRINT*,'Pop failed: empty buffer'
         STOP
      END IF  
      H = buf_H( stack_ptr )
      T = buf_T( stack_ptr )
      CALL WCOPY(KPPNSP,buf_Y(1:KPPNSP,stack_ptr),1,Y,1)
      CALL WCOPY(KPPNSP,buf_dY(1:KPPNSP,stack_ptr),1,dY,1)
      CALL WCOPY(KPPNSP,buf_d2Y(1:KPPNSP,stack_ptr),1,d2Y,1)

      stack_ptr = stack_ptr - 1
      
      END SUBROUTINE ros_CPop

C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE RosenbrockADJ( Y, NADJ, Lambda,   
     &     Tstart,Tend,                      
     &     AbsTol,RelTol,                    
     &     RCNTRL,ICNTRL,RSTATUS,ISTATUS,IERR,RKI)
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      IMPLICIT NONE
      
C~~~  >  Arguments   
      REAL(kind=dp), INTENT(INOUT) :: Y(KPPNSP)
      INTEGER, INTENT(IN)     :: NADJ
      REAL(kind=dp), INTENT(INOUT) :: Lambda(KPPNSP,NADJ)
      REAL(kind=dp), INTENT(IN)   :: Tstart,Tend
      REAL(kind=dp), INTENT(IN)   :: AbsTol(KPPNSP),RelTol(KPPNSP)
      INTEGER, INTENT(IN)    :: ICNTRL(10)
      REAL(kind=dp), INTENT(IN)   :: RCNTRL(10)
      INTEGER, INTENT(INOUT) :: ISTATUS(20)
      REAL(kind=dp), INTENT(INOUT) :: RSTATUS(20)
      INTEGER, INTENT(OUT)   :: IERR
C~~~  >  The method parameters   
      INTEGER, PARAMETER :: Smax = 6
      INTEGER  :: Method, ros_S
      REAL(kind=dp), DIMENSION(Smax) :: ros_M, ros_E, ros_Alpha, ros_Gamma
      REAL(kind=dp), DIMENSION(Smax*(Smax-1)/2) :: ros_A, ros_C
      REAL(kind=dp) :: ros_ELO
      LOGICAL, DIMENSION(Smax) :: ros_NewF
      CHARACTER(LEN=12) :: ros_Name
C~~~  >  Local variables     
      REAL(kind=dp) :: Roundoff, FacMin, FacMax, FacRej, FacSafe
      REAL(kind=dp) :: Hmin, Hmax, Hstart, Hexit
      REAL(kind=dp) :: Texit
      INTEGER :: i, UplimTol, Max_no_steps
      INTEGER :: AdjointType, CadjMethod 
      LOGICAL :: Autonomous, VectorTol
C~~~  >   Parameters
      REAL(kind=dp), PARAMETER :: ZERO = 0.0d0, ONE  = 1.0d0
      REAL(kind=dp), PARAMETER :: DeltaMin = 1.0d-5

      REAL(kind=dp) :: RKI(KPPNRCT)

C~~~  >  Initialize statistics
      Nfun = ISTATUS(ifun)
      Njac = ISTATUS(ijac)
      Nstp = ISTATUS(istp)
      Nacc = ISTATUS(iacc)
      Nrej = ISTATUS(irej)
      Ndec = ISTATUS(idec)
      Nsol = ISTATUS(isol)
      Nsng = ISTATUS(isng)
      
C~~~  >  Autonomous or time dependent ODE. Default is time dependent.
      Autonomous = .NOT.(ICNTRL(1) == 0)

C~~~  >  For Scalar tolerances (ICNTRL(2).NE.0)  the code uses AbsTol(1) and RelTol(1)
C     For Vector tolerances (ICNTRL(2) == 0) the code uses AbsTol(1:KPPNSP) and RelTol(1:KPPNSP)
      IF (ICNTRL(2) == 0) THEN
         VectorTol = .TRUE.
         UplimTol  = KPPNSP
      ELSE 
         VectorTol = .FALSE.
         UplimTol  = 1
      END IF
      
C~~~  >   The maximum number of steps admitted
      IF (ICNTRL(3) == 0) THEN
         Max_no_steps = bufsize - 1
      ELSEIF (Max_no_steps > 0) THEN
         Max_no_steps=ICNTRL(3)
      ELSE 
         PRINT * ,'User-selected max no. of steps: ICNTRL(3)=',ICNTRL(3)
         CALL ros_ErrorMsg(-1,Tstart,ZERO,IERR)
         RETURN      
      END IF

C~~~  >  The particular Rosenbrock method chosen
      IF (ICNTRL(4) == 0) THEN
         Method = 5
      ELSEIF ( (ICNTRL(4) >= 1).AND.(ICNTRL(4) <= 5) ) THEN
         Method = ICNTRL(4)
      ELSE  
         PRINT * , 'User-selected Rosenbrock method: ICNTRL(4)=', Method
         CALL ros_ErrorMsg(-2,Tstart,ZERO,IERR)
         RETURN      
      END IF

C~~~  >  Discrete or continuous adjoint formulation
      IF ( ICNTRL(5) == 0 ) THEN
         AdjointType = Adj_discrete
      ELSEIF ( (ICNTRL(5) >= 1).AND.(ICNTRL(5) <= 4) ) THEN
         AdjointType = ICNTRL(5)
      ELSE  
         PRINT * , 'User-selected adjoint type: ICNTRL(5)=', AdjointType
         CALL ros_ErrorMsg(-9,Tstart,ZERO,IERR)
         RETURN      
      END IF

C~~~  >  The particular Rosenbrock method chosen for integrating the cts adjoint
      IF (ICNTRL(6) == 0) THEN
         CadjMethod = 4
      ELSEIF ( (ICNTRL(6) >= 1).AND.(ICNTRL(6) <= 5) ) THEN
         CadjMethod = ICNTRL(4)
      ELSE  
         PRINT * , 'User-selected CADJ Rosenbrock method: ICNTRL(6)=', Method
         CALL ros_ErrorMsg(-2,Tstart,ZERO,IERR)
         RETURN      
      END IF

      
C~~~  >  Unit roundoff (1+Roundoff>1)  
      Roundoff = WLAMCH('E')

C~~~  >  Lower bound on the step size: (positive value)
      IF (RCNTRL(1) == ZERO) THEN
         Hmin = ZERO
      ELSEIF (RCNTRL(1) > ZERO) THEN 
         Hmin = RCNTRL(1)
      ELSE  
         PRINT * , 'User-selected Hmin: RCNTRL(1)=', RCNTRL(1)
         CALL ros_ErrorMsg(-3,Tstart,ZERO,IERR)
         RETURN      
      END IF
C~~~  >  Upper bound on the step size: (positive value)
      IF (RCNTRL(2) == ZERO) THEN
         Hmax = ABS(Tend-Tstart)
      ELSEIF (RCNTRL(2) > ZERO) THEN
         Hmax = MIN(ABS(RCNTRL(2)),ABS(Tend-Tstart))
      ELSE  
         PRINT * , 'User-selected Hmax: RCNTRL(2)=', RCNTRL(2)
         CALL ros_ErrorMsg(-3,Tstart,ZERO,IERR)
         RETURN      
      END IF
C~~~  >  Starting step size: (positive value)
      IF (RCNTRL(3) == ZERO) THEN
         Hstart = MAX(Hmin,DeltaMin)
      ELSEIF (RCNTRL(3) > ZERO) THEN
         Hstart = MIN(ABS(RCNTRL(3)),ABS(Tend-Tstart))
      ELSE  
         PRINT * , 'User-selected Hstart: RCNTRL(3)=', RCNTRL(3)
         CALL ros_ErrorMsg(-3,Tstart,ZERO,IERR)
         RETURN      
      END IF
C~~~  >  Step size can be changed s.t.  FacMin < Hnew/Hexit < FacMax 
      IF (RCNTRL(4) == ZERO) THEN
         FacMin = 0.2d0
      ELSEIF (RCNTRL(4) > ZERO) THEN
         FacMin = RCNTRL(4)
      ELSE  
         PRINT * , 'User-selected FacMin: RCNTRL(4)=', RCNTRL(4)
         CALL ros_ErrorMsg(-4,Tstart,ZERO,IERR)
         RETURN      
      END IF
      IF (RCNTRL(5) == ZERO) THEN
         FacMax = 6.0d0
      ELSEIF (RCNTRL(5) > ZERO) THEN
         FacMax = RCNTRL(5)
      ELSE  
         PRINT * , 'User-selected FacMax: RCNTRL(5)=', RCNTRL(5)
         CALL ros_ErrorMsg(-4,Tstart,ZERO,IERR)
         RETURN      
      END IF
C~~~  >   FacRej: Factor to decrease step after 2 succesive rejections
      IF (RCNTRL(6) == ZERO) THEN
         FacRej = 0.1d0
      ELSEIF (RCNTRL(6) > ZERO) THEN
         FacRej = RCNTRL(6)
      ELSE  
         PRINT * , 'User-selected FacRej: RCNTRL(6)=', RCNTRL(6)
         CALL ros_ErrorMsg(-4,Tstart,ZERO,IERR)
         RETURN      
      END IF
C~~~  >   FacSafe: Safety Factor in the computation of new step size
      IF (RCNTRL(7) == ZERO) THEN
         FacSafe = 0.9d0
      ELSEIF (RCNTRL(7) > ZERO) THEN
         FacSafe = RCNTRL(7)
      ELSE  
         PRINT * , 'User-selected FacSafe: RCNTRL(7)=', RCNTRL(7)
         CALL ros_ErrorMsg(-4,Tstart,ZERO,IERR)
         RETURN      
      END IF
C~~~  >  Check if tolerances are reasonable
      DO i=1,UplimTol
         IF ( (AbsTol(i) <= ZERO) .OR. (RelTol(i) <= 10.d0*Roundoff)  
     &        .OR. (RelTol(i) >= 1.0d0) ) THEN
         PRINT * , ' AbsTol(',i,') = ',AbsTol(i)
         PRINT * , ' RelTol(',i,') = ',RelTol(i)
         CALL ros_ErrorMsg(-5,Tstart,ZERO,IERR)
         RETURN
      END IF
      END DO
      
      
C~~~  >   Initialize the particular RosenbrockADJ method
      SELECT CASE (Method)
      CASE (1)
         CALL Ros2(ros_S, ros_A, ros_C, ros_M, ros_E,     
     &        ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
      CASE (2)
         CALL Ros3(ros_S, ros_A, ros_C, ros_M, ros_E,     
     &        ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
      CASE (3)
         CALL Ros4(ros_S, ros_A, ros_C, ros_M, ros_E,     
     &        ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
      CASE (4)
         CALL Rodas3(ros_S, ros_A, ros_C, ros_M, ros_E,   
     &        ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
      CASE (5)
         CALL Rodas4(ros_S, ros_A, ros_C, ros_M, ros_E,   
     &        ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
      CASE DEFAULT
         PRINT * , 'Unknown Rosenbrock method: ICNTRL(4)=', Method
         CALL ros_ErrorMsg(-2,Tstart,ZERO,IERR) 
         RETURN     
      END SELECT
      
C~~~  >  Allocate checkpoint space or open checkpoint files
      IF (AdjointType == Adj_discrete) THEN
         CALL ros_AllocateDBuffers( ros_S )
      ELSEIF ( (AdjointType == Adj_continuous).OR.  
     &        (AdjointType == Adj_simple_continuous) ) THEN
         CALL ros_AllocateCBuffers
      END IF
      
C~~~  >  CALL Forward Rosenbrock method   
      CALL ros_FwdInt(Y,Tstart,Tend,Texit,            
     &     AbsTol, RelTol,                            
C     RosenbrockADJ method coefficients     
     &     ros_S, ros_M, ros_E, ros_A, ros_C,         
     &     ros_Alpha, ros_Gamma, ros_ELO, ros_NewF,   
C     Integration parameters
     &     Autonomous, VectorTol, AdjointType,       
     &     Max_no_steps,                              
     &     Roundoff, Hmin, Hmax, Hstart, Hexit,       
     &     FacMin, FacMax, FacRej, FacSafe,           
C     Error indicator
     &     IERR,RKI)
      
C     PRINT*,'FORWARD STATISTICS'
C     PRINT*,'Step=',Nstp,' Acc=',Nacc,    
C     ' Rej=',Nrej, ' Singular=',Nsng
      Nstp = 0
      Nacc = 0
      Nrej = 0
      Nsng = 0

C~~~  >  If Forward integration failed return   
      IF (IERR<0) RETURN

C~~~  >   Initialize the particular Rosenbrock method for continuous adjoint
      IF ( (AdjointType == Adj_continuous).OR.  
     &     (AdjointType == Adj_simple_continuous) ) THEN
      SELECT CASE (CadjMethod)
      CASE (1)
         CALL Ros2(ros_S, ros_A, ros_C, ros_M, ros_E,     
     &        ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
      CASE (2)
         CALL Ros3(ros_S, ros_A, ros_C, ros_M, ros_E,     
     &        ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
      CASE (3)
         CALL Ros4(ros_S, ros_A, ros_C, ros_M, ros_E,     
     &        ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
      CASE (4)
         CALL Rodas3(ros_S, ros_A, ros_C, ros_M, ros_E,   
     &        ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
      CASE (5)
         CALL Rodas4(ros_S, ros_A, ros_C, ros_M, ros_E,   
     &        ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
      CASE DEFAULT
         PRINT * , 'Unknown Rosenbrock method: ICNTRL(4)=', Method
         CALL ros_ErrorMsg(-2,Tstart,ZERO,IERR) 
         RETURN     
      END SELECT
      END IF

      SELECT CASE (AdjointType)   
      CASE (Adj_discrete)   
         CALL ros_DadjInt (                           
     &        NADJ, Lambda,                             
     &        Tstart, Tend, Texit,                      
     &        AbsTol, RelTol,                           
     &        ros_S, ros_M, ros_E, ros_A, ros_C,        
     &        ros_Alpha, ros_Gamma, ros_ELO, ros_NewF,  
     &        Autonomous, VectorTol, Max_no_steps,      
     &        Roundoff, Hmin, Hmax, Hstart,             
     &        FacMin, FacMax, FacRej, FacSafe,          
     &        IERR, RKI )
      CASE (Adj_continuous) 
         CALL ros_CadjInt (                           
     &        NADJ, Lambda,                             
     &        Tend, Tstart, Texit,                      
     &        AbsTol, RelTol,                           
     &        ros_S, ros_M, ros_E, ros_A, ros_C,        
     &        ros_Alpha, ros_Gamma, ros_ELO, ros_NewF,  
     &        Autonomous, VectorTol, AdjointType,       
     &        100000,                                   
     &        Roundoff, Hmin, Hmax, Hstart, Hexit,      
     &        FacMin, FacMax, FacRej, FacSafe,          
     &        IERR, RKI )
      CASE (Adj_simple_continuous)
         CALL ros_SimpleCadjInt (                     
     &        NADJ, Lambda,                             
     &        Tstart, Tend, Texit,                      
     &        AbsTol, RelTol,                           
     &        ros_S, ros_M, ros_E, ros_A, ros_C,        
     &        ros_Alpha, ros_Gamma, ros_ELO, ros_NewF,  
     &        Autonomous, VectorTol, AdjointType,       
     &        Max_no_steps,                             
     &        Roundoff, Hmin, Hmax, Hstart,             
     &        FacMin, FacMax, FacRej, FacSafe,          
     &        IERR, RKI )
      END SELECT                ! AdjointType

C     PRINT*,'ADJOINT STATISTICS'
C     PRINT*,'Step=',Nstp,' Acc=',Nacc,              
C     ' Rej=',Nrej, ' Singular=',Nsng

C~~~  >  Free checkpoint space or close checkpoint files
      IF (AdjointType == Adj_discrete) THEN
         CALL ros_FreeDBuffers
      ELSEIF ( (AdjointType == Adj_continuous) .OR.  
     &        (AdjointType == Adj_simple_continuous) ) THEN
         CALL ros_FreeCBuffers
      END IF

C~~~  >  Collect run statistics
      ISTATUS(ifun) = Nfun
      ISTATUS(ijac) = Njac
      ISTATUS(istp) = Nstp
      ISTATUS(iacc) = Nacc
      ISTATUS(irej) = Nrej
      ISTATUS(idec) = Ndec
      ISTATUS(isol) = Nsol
      ISTATUS(isng) = Nsng
C~~~  > Last T and H
      RSTATUS(itexit) = Texit
      RSTATUS(ihexit) = Hexit    
      

      END SUBROUTINE RosenbrockADJ
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_ErrorMsg(Code,T,H,IERR)
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     Handles all error messages
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
      REAL(kind=dp), INTENT(IN) :: T, H
      INTEGER, INTENT(IN)  :: Code
      INTEGER, INTENT(OUT) :: IERR
      
      IERR = Code
      PRINT * ,  
     &     'Forced exit from RosenbrockADJ due to the following error:' 
      
      SELECT CASE (Code)
      CASE (-1)    
         PRINT * , '--> Improper value for maximal no of steps'
      CASE (-2)    
         PRINT * , '--> Selected RosenbrockADJ method not implemented'
      CASE (-3)    
         PRINT * , '--> Hmin/Hmax/Hstart must be positive'
      CASE (-4)    
         PRINT * , '--> FacMin/FacMax/FacRej must be positive'
      CASE (-5) 
         PRINT * , '--> Improper tolerance values'
      CASE (-6) 
         PRINT * , '--> No of steps exceeds maximum buffer bound'
      CASE (-7) 
         PRINT * , '--> Step size too small: T + 10*H = T',  
     &        ' or H < Roundoff'
      CASE (-8)    
         PRINT * , '--> Matrix is repeatedly singular'
      CASE (-9)    
         PRINT * , '--> Improper type of adjoint selected'
      CASE DEFAULT
         PRINT *, 'Unknown Error code: ', Code
      END SELECT
      
      PRINT *, "T=", T, "and H=", H
      
      END SUBROUTINE ros_ErrorMsg
      
      
      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_FwdInt (Y,                        
     &     Tstart, Tend, T,                          
     &     AbsTol, RelTol,                           
C~~~  > RosenbrockADJ method coefficients     
     &     ros_S, ros_M, ros_E, ros_A, ros_C,        
     &     ros_Alpha, ros_Gamma, ros_ELO, ros_NewF,  
C~~~  > Integration parameters
     &     Autonomous, VectorTol, AdjointType,       
     &     Max_no_steps,                             
     &     Roundoff, Hmin, Hmax, Hstart, Hexit,      
     &     FacMin, FacMax, FacRej, FacSafe,          
C~~~  > Error indicator
     &     IERR, RKI )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     Template for the implementation of a generic RosenbrockADJ method 
C     defined by ros_S (no of stages)  
C     and its coefficients ros_{A,C,M,E,Alpha,Gamma}
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      IMPLICIT NONE
      
C~~~  > Input: the initial condition at Tstart; Output: the solution at T   
      REAL(kind=dp), INTENT(INOUT) :: Y(KPPNSP)
C~~~  > Input: integration interval   
      REAL(kind=dp), INTENT(IN) :: Tstart,Tend      
C~~~  > Output: time at which the solution is returned (T=Tend if success)   
      REAL(kind=dp), INTENT(OUT) ::  T      
C~~~  > Input: tolerances      
      REAL(kind=dp), INTENT(IN) ::  AbsTol(KPPNSP), RelTol(KPPNSP)
C~~~  > Input: The RosenbrockADJ method parameters   
      INTEGER, INTENT(IN) ::  ros_S
      REAL(kind=dp), INTENT(IN) :: ros_M(ros_S), ros_E(ros_S),    
     &     ros_Alpha(ros_S), ros_A(ros_S*(ros_S-1)/2),  
     &     ros_Gamma(ros_S), ros_C(ros_S*(ros_S-1)/2), ros_ELO
      LOGICAL, INTENT(IN) :: ros_NewF(ros_S)
C~~~  > Input: integration parameters   
      LOGICAL, INTENT(IN) :: Autonomous, VectorTol
      INTEGER, INTENT(IN) :: AdjointType
      REAL(kind=dp), INTENT(IN) :: Hstart, Hmin, Hmax
      INTEGER, INTENT(IN) :: Max_no_steps
      REAL(kind=dp), INTENT(IN) :: Roundoff, FacMin, FacMax, FacRej, FacSafe 
C~~~  > Output: last accepted step   
      REAL(kind=dp), INTENT(OUT) :: Hexit 
C~~~  > Output: Error indicator
      INTEGER, INTENT(OUT) :: IERR
C     ~~~~ Local variables        
      REAL(kind=dp) :: Ynew(KPPNSP), Fcn0(KPPNSP), Fcn(KPPNSP) 
      REAL(kind=dp) :: K(KPPNSP*ros_S), dFdT(KPPNSP)
      REAL(kind=dp), DIMENSION(:), POINTER :: Ystage
      REAL(kind=dp) :: Jac0(LU_NONZERO), Ghimj(LU_NONZERO)
      REAL(kind=dp) :: H, Hnew, HC, HG, Fac, Tau 
      REAL(kind=dp) :: Err, Yerr(KPPNSP)
      INTEGER :: Pivot(KPPNSP), Direction, ioffset, i, j, istage
      LOGICAL :: RejectLastH, RejectMoreH, Singular
C~~~  >  Local parameters
      REAL(kind=dp), PARAMETER :: DeltaMin = 1.0d-5
C~~~  >  Locally called functions
C     REAL(kind=dp) WLAMCH
C     EXTERNAL WLAMCH
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      REAL(kind=dp) :: RKI(KPPNRCT)


C~~~  >  Allocate stage vector buffer if needed
      IF (AdjointType == Adj_discrete) THEN ! Save stage solution
         ALLOCATE(Ystage(KPPNSP*ros_S), STAT=i)
         IF (i/=0) THEN
            PRINT*,'Allocation of Ystage failed'
            STOP
         END IF
      END IF   
      
C~~~  >  Initial preparations
      T = Tstart
      Hexit = 0.0_dp
      H = MIN(Hstart,Hmax) 
      IF (ABS(H) <= 10.0_dp*Roundoff) H = DeltaMin
      
      IF (Tend  >=  Tstart) THEN
         Direction = +1
      ELSE
         Direction = -1
      END IF               

      RejectLastH=.FALSE.
      RejectMoreH=.FALSE.
      
C~~~  > Time loop begins below 

      TimeLoop: DO WHILE ( (Direction > 0).AND.((T-Tend)+Roundoff <= ZERO)  
     &     .OR. (Direction < 0).AND.((Tend-T)+Roundoff <= ZERO) ) 
      
      IF ( Nstp > Max_no_steps ) THEN ! Too many steps
         CALL ros_ErrorMsg(-6,T,H,IERR)
         RETURN
      END IF
      IF ( ((T+0.1d0*H) == T).OR.(H <= Roundoff) ) THEN ! Step size too small
         CALL ros_ErrorMsg(-7,T,H,IERR)
         RETURN
      END IF
      
C~~~  >  Limit H if necessary to avoid going beyond Tend   
      Hexit = H
      H = MIN(H,ABS(Tend-T))

C~~~  >   Compute the function at current time
      CALL FunTemplate(Y,RKI,Fcn0)

C     !~~~>  Compute the function derivative with respect to T
C     IF (.NOT.Autonomous) THEN
C     CALL ros_FunTimeDerivative ( T, Roundoff, Y,  
C     Fcn0, dFdT )
C     END IF
      
C~~~  >   Compute the Jacobian at current time
      CALL JacTemplate(Y,RKI,Jac0)
      
C~~~  >  Repeat step calculation until current step accepted
      UntilAccepted: DO  
      
      CALL ros_PrepareMatrix(H,Direction,ros_Gamma(1),  
     &     Jac0,Ghimj,Pivot,Singular)
      IF (Singular) THEN        ! More than 5 consecutive failed decompositions
         CALL ros_ErrorMsg(-8,T,H,IERR)
         RETURN
      END IF

C~~~  >   Compute the stages
      Stage: DO istage = 1, ros_S
      
                                ! Current istage offset. Current istage vector is K(ioffset+1:ioffset+KPPNSP)
      ioffset = KPPNSP*(istage-1)
      
                                ! For the 1st istage the function has been computed previously
      IF ( istage == 1 ) THEN
         CALL WCOPY(KPPNSP,Fcn0,1,Fcn,1)
         IF (AdjointType == Adj_discrete) THEN ! Save stage solution
            CALL WCOPY(KPPNSP,Y,1,Ystage(1:KPPNSP),1)
         END IF   
                                ! istage>1 and a new function evaluation is needed at the current istage
      ELSEIF ( ros_NewF(istage) ) THEN
         CALL WCOPY(KPPNSP,Y,1,Ynew,1)
         DO j = 1, istage-1
            CALL WAXPY(KPPNSP,ros_A((istage-1)*(istage-2)/2+j),  
     &           K(KPPNSP*(j-1)+1),1,Ynew,1) 
         END DO
         Tau = T + ros_Alpha(istage)*Direction*H
         CALL FunTemplate(Ynew,RKI,Fcn)
         IF (AdjointType == Adj_discrete) THEN ! Save stage solution
            CALL WCOPY(KPPNSP,Ynew,1,Ystage(ioffset+1:ioffset+KPPNSP),1)
         END IF   
      END IF                    ! if istage == 1 elseif ros_NewF(istage)
      CALL WCOPY(KPPNSP,Fcn,1,K(ioffset+1),1)
      DO j = 1, istage-1
         HC = ros_C((istage-1)*(istage-2)/2+j)/(Direction*H)
         CALL WAXPY(KPPNSP,HC,K(KPPNSP*(j-1)+1),1,K(ioffset+1),1)
      END DO
      IF ((.NOT. Autonomous).AND.(ros_Gamma(istage).NE.ZERO)) THEN
         HG = Direction*H*ros_Gamma(istage)
         CALL WAXPY(KPPNSP,HG,dFdT,1,K(ioffset+1),1)
      END IF
      CALL ros_Solve('N', Ghimj, Pivot, K(ioffset+1))
      
      END DO Stage     
      

C~~~  >  Compute the new solution 
      CALL WCOPY(KPPNSP,Y,1,Ynew,1)
      DO j=1,ros_S
         CALL WAXPY(KPPNSP,ros_M(j),K(KPPNSP*(j-1)+1),1,Ynew,1)
      END DO

C~~~  >  Compute the error estimation 
      CALL WSCAL(KPPNSP,ZERO,Yerr,1)
      DO j=1,ros_S     
         CALL WAXPY(KPPNSP,ros_E(j),K(KPPNSP*(j-1)+1),1,Yerr,1)
      END DO 
      Err = ros_ErrorNorm ( Y, Ynew, Yerr, AbsTol, RelTol, VectorTol )

C~~~  > New step size is bounded by FacMin <= Hnew/H <= FacMax
      Fac  = MIN(FacMax,MAX(FacMin,FacSafe/Err**(ONE/ros_ELO)))
      Hnew = H*Fac  

C~~~  >  Check the error magnitude and adjust step size
      Nstp = Nstp+1
      IF ( (Err <= ONE).OR.(H <= Hmin) ) THEN !~~~> Accept step
         Nacc = Nacc+1
         IF (AdjointType == Adj_discrete) THEN ! Save current state
            CALL ros_DPush( ros_S, T, H, Ystage, K ) !, Ghimj )
         ELSEIF ( (AdjointType == Adj_continuous) .OR. 
     &           (AdjointType == Adj_simple_continuous) ) THEN
            CALL Jac_SP_Vec( Jac0, Fcn0, K(1) )
            IF (.NOT. Autonomous) THEN
               CALL WAXPY(KPPNSP,ONE,dFdT,1,K(1),1)
            END IF   
            CALL ros_CPush( T, H, Y, Fcn0, K(1) )
         END IF      
         CALL WCOPY(KPPNSP,Ynew,1,Y,1)
         T = T + Direction*H
         Hnew = MAX(Hmin,MIN(Hnew,Hmax))
         IF (RejectLastH) THEN  ! No step size increase after a rejected step
            Hnew = MIN(Hnew,H) 
         END IF   
         RejectLastH = .FALSE.  
         RejectMoreH = .FALSE.
         H = Hnew      
         EXIT UntilAccepted     ! EXIT THE LOOP: WHILE STEP NOT ACCEPTED
      ELSE                      !~~~> Reject step
         IF (RejectMoreH) THEN
            Hnew = H*FacRej
         END IF   
         RejectMoreH = RejectLastH
         RejectLastH = .TRUE.
         H = Hnew
         IF (Nacc >= 1) THEN
            Nrej = Nrej+1
         END IF    
      END IF                    ! Err <= 1

      END DO UntilAccepted 

      END DO TimeLoop 
      
C~~~  > Save last state: only needed for continuous adjoint
      IF ( (AdjointType == Adj_continuous) .OR.  
     &     (AdjointType == Adj_simple_continuous) ) THEN
         CALL FunTemplate(Y,RKI,Fcn0)
         CALL JacTemplate(Y,RKI,Jac0)
         CALL Jac_SP_Vec( Jac0, Fcn0, K(1) )
         IF (.NOT. Autonomous) THEN
            CALL ros_FunTimeDerivative ( T, Roundoff, Y,  
     &           Fcn0, dFdT )
            CALL WAXPY(KPPNSP,ONE,dFdT,1,K(1),1)
         END IF   
         CALL ros_CPush( T, H, Y, Fcn0, K(1) )
C~~~  > Deallocate stage buffer: only needed for discrete adjoint
      ELSEIF (AdjointType == Adj_discrete) THEN 
         DEALLOCATE(Ystage, STAT=i)
         IF (i/=0) THEN
            PRINT*,'Deallocation of Ystage failed'
            STOP
         END IF
      END IF   
      
C~~~  > Succesful exit
      IERR = 1                  !~~~> The integration was successful

C     PRINT*,'Nacc after fwd =',Nacc

      END SUBROUTINE ros_FwdInt
      
      
      
      
      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_DadjInt (                         
     &     NADJ, Lambda,                             
     &     Tstart, Tend, T,                          
     &     AbsTol, RelTol,                           
C~~~  > RosenbrockSOA method coefficients     
     &     ros_S, ros_M, ros_E, ros_A, ros_C,        
     &     ros_Alpha, ros_Gamma, ros_ELO, ros_NewF,  
C~~~  > Integration parameters
     &     Autonomous, VectorTol, Max_no_steps,      
     &     Roundoff, Hmin, Hmax, Hstart,             
     &     FacMin, FacMax, FacRej, FacSafe,          
C~~~  > Error indicator
     &     IERR,RKI )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     Template for the implementation of a generic RosenbrockSOA method 
C     defined by ros_S (no of stages)  
C     and its coefficients ros_{A,C,M,E,Alpha,Gamma}
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      IMPLICIT NONE
      
C~~~  > Input: the initial condition at Tstart; Output: the solution at T   
      INTEGER, INTENT(IN)     :: NADJ
C~~~  > First order adjoint   
      REAL(kind=dp), INTENT(INOUT) :: Lambda(KPPNSP,NADJ)
C     !~~~> Input: integration interval   
      REAL(kind=dp), INTENT(IN) :: Tstart,Tend      
C~~~  > Output: time at which the solution is returned (T=Tend if success)   
      REAL(kind=dp), INTENT(OUT) ::  T      
C~~~  > Input: tolerances      
      REAL(kind=dp), INTENT(IN) ::  AbsTol(KPPNSP), RelTol(KPPNSP)
C~~~  > Input: The RosenbrockSOA method parameters   
      INTEGER, INTENT(IN) ::  ros_S
      REAL(kind=dp), INTENT(IN) :: ros_M(ros_S), ros_E(ros_S),    
     &     ros_Alpha(ros_S), ros_A(ros_S*(ros_S-1)/2),       
     &     ros_Gamma(ros_S), ros_C(ros_S*(ros_S-1)/2), ros_ELO
      LOGICAL, INTENT(IN) :: ros_NewF(ros_S)
C~~~  > Input: integration parameters   
      LOGICAL, INTENT(IN) :: Autonomous, VectorTol
      REAL(kind=dp), INTENT(IN) :: Hstart, Hmin, Hmax
      INTEGER, INTENT(IN) :: Max_no_steps
      REAL(kind=dp), INTENT(IN) :: Roundoff, FacMin, FacMax, FacRej, FacSafe 
C~~~  > Output: Error indicator
      INTEGER, INTENT(OUT) :: IERR
C     ~~~~ Local variables        
      REAL(kind=dp) :: Ystage_adj(KPPNSP,NADJ)
      REAL(kind=dp) :: dFdT(KPPNSP)
      REAL(kind=dp) :: Ystage(KPPNSP*ros_S), K(KPPNSP*ros_S)
      REAL(kind=dp) :: U(KPPNSP*ros_S,NADJ), V(KPPNSP*ros_S,NADJ)
      REAL(kind=dp) :: Jac(LU_NONZERO), dJdT(LU_NONZERO), Ghimj(LU_NONZERO)
      REAL(kind=dp) :: Hes0(NHESS), Hes1(NHESS), dHdT(NHESS)
      REAL(kind=dp) :: Tmp(KPPNSP), Tmp2(KPPNSP)
      REAL(kind=dp) :: H, HC, HA, Tau 
      INTEGER :: Pivot(KPPNSP), Direction
      INTEGER :: i, j, m, istage, istart, jstart
C~~~  >  Local parameters
      REAL(kind=dp), PARAMETER :: ZERO = 0.0d0, ONE  = 1.0d0 
      REAL(kind=dp), PARAMETER :: DeltaMin = 1.0d-5
C~~~  >  Locally called functions
C     REAL(kind=dp) WLAMCH
C     EXTERNAL WLAMCH
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      REAL(kind=dp) :: RKI(KPPNRCT)
      
      
      IF (Tend  >=  Tstart) THEN
         Direction = +1
      ELSE
         Direction = -1
      END IF               

      OPEN(55,file='CMAQ_CB4_dadj.dat')

C~~~  > Time loop begins below 
      TimeLoop: DO WHILE ( stack_ptr > 0 )
      
                                !~~~>  Recover checkpoints for stage values and vectors
      CALL ros_DPop( ros_S, T, H, Ystage, K ) !, Ghimj )

      Nstp = Nstp+1

C~~~  >    Compute LU decomposition 
      CALL JacTemplate(Ystage(1),RKI,Ghimj)
      CALL WSCAL(LU_NONZERO,(-ONE),Ghimj,1)
      Tau = ONE/(Direction*H*ros_Gamma(1))
      DO i=1,KPPNSP
         Ghimj(LU_DIAG(i)) = Ghimj(LU_DIAG(i))+Tau
      END DO
      CALL ros_Decomp( Ghimj, Pivot, j )
      
C~~~  >   Compute Hessian at the beginning of the interval
      CALL HessTemplate(Ystage(1),RKI,Hes0)
      
C~~~  >   Compute the stages
      Stage: DO istage = ros_S, 1, -1
      
                                !~~~> Current istage first entry 
      istart = KPPNSP*(istage-1) + 1
      
                                !~~~> Compute U
      DO m = 1,NADJ
         CALL WCOPY(KPPNSP,Lambda(1,m),1,U(istart,m),1)
         CALL WSCAL(KPPNSP,ros_M(istage),U(istart,m),1)
      END DO                    ! m=1:NADJ
      DO j = istage+1, ros_S
         jstart = KPPNSP*(j-1) + 1
         HA = ros_A((j-1)*(j-2)/2+istage)
         HC = ros_C((j-1)*(j-2)/2+istage)/(Direction*H)
         DO m = 1,NADJ
            CALL WAXPY(KPPNSP,HA,V(jstart,m),1,U(istart,m),1) 
            CALL WAXPY(KPPNSP,HC,U(jstart,m),1,U(istart,m),1) 
         END DO                 ! m=1:NADJ
      END DO
      DO m = 1,NADJ
         CALL ros_Solve('T', Ghimj, Pivot, U(istart,m))
      END DO                    ! m=1:NADJ
                                !~~~> Compute V 
      Tau = T + ros_Alpha(istage)*Direction*H
      CALL JacTemplate(Ystage(istart),RKI,Jac)
      DO m = 1,NADJ
         CALL JacTR_SP_Vec(Jac,U(istart,m),V(istart,m)) 
      END DO                    ! m=1:NADJ
      
      END DO Stage     

      IF (.NOT.Autonomous) THEN
C~~~  >  Compute the Jacobian derivative with respect to T. 
C     Last "Jac" computed for stage 1
         CALL ros_JacTimeDerivative ( T, Roundoff, Ystage(1),         
     &        Jac, dJdT )
      END IF

C~~~  >  Compute the new solution 
      
                                !~~~>  Compute Lambda 
      DO istage=1,ros_S
         istart = KPPNSP*(istage-1) + 1
         DO m = 1,NADJ
                                ! Add V_i
            CALL WAXPY(KPPNSP,ONE,V(istart,m),1,Lambda(1,m),1)
                                ! Add (H0xK_i)^T * U_i
            CALL HessTR_Vec ( Hes0, U(istart,m), K(istart), Tmp )
            CALL WAXPY(KPPNSP,ONE,Tmp,1,Lambda(1,m),1)
         END DO                 ! m=1:NADJ
      END DO
                                !        Add H * dJac_dT_0^T * \sum(gamma_i U_i)
                                !        Tmp holds sum gamma_i U_i
      IF (.NOT.Autonomous) THEN
         DO m = 1,NADJ
            Tmp(1:KPPNSP) = ZERO
            DO istage = 1, ros_S
               istart = KPPNSP*(istage-1) + 1
               CALL WAXPY(KPPNSP,ros_Gamma(istage),U(istart,m),1,Tmp,1)
            END DO  
            CALL JacTR_SP_Vec(dJdT,Tmp,Tmp2) 
            CALL WAXPY(KPPNSP,H,Tmp2,1,Lambda(1,m),1)
         END DO                 ! m=1:NADJ
      END IF                    ! .NOT.Autonomous
      

      END DO TimeLoop 
      
C~~~  > Save last state
      
C~~~  > Succesful exit
      IERR = 1                  !~~~> The integration was successful

C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      END SUBROUTINE ros_DadjInt
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
      
      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_CadjInt (                         
     &     NADJ, Y,                                  
     &     Tstart, Tend, T,                          
     &     AbsTol, RelTol,                           
C~~~  > RosenbrockADJ method coefficients     
     &     ros_S, ros_M, ros_E, ros_A, ros_C,        
     &     ros_Alpha, ros_Gamma, ros_ELO, ros_NewF,  
C~~~  > Integration parameters
     &     Autonomous, VectorTol, AdjointType,       
     &     Max_no_steps,                             
     &     Roundoff, Hmin, Hmax, Hstart, Hexit,      
     &     FacMin, FacMax, FacRej, FacSafe,          
C~~~  > Error indicator
     &     IERR,RKI )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     Template for the implementation of a generic RosenbrockADJ method 
C     defined by ros_S (no of stages)  
C     and its coefficients ros_{A,C,M,E,Alpha,Gamma}
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      IMPLICIT NONE
      
C~~~  > Input: the initial condition at Tstart; Output: the solution at T   
      INTEGER, INTENT(IN) :: NADJ
      REAL(kind=dp), INTENT(INOUT) :: Y(KPPNSP,NADJ)
C~~~  > Input: integration interval   
      REAL(kind=dp), INTENT(IN) :: Tstart,Tend      
C~~~  > Output: time at which the solution is returned (T=Tend if success)   
      REAL(kind=dp), INTENT(OUT) ::  T      
C~~~  > Input: tolerances      
      REAL(kind=dp), INTENT(IN) ::  AbsTol(KPPNSP), RelTol(KPPNSP)
C~~~  > Input: The RosenbrockADJ method parameters   
      INTEGER, INTENT(IN) ::  ros_S
      REAL(kind=dp), INTENT(IN) :: ros_M(ros_S), ros_E(ros_S),    
     &     ros_Alpha(ros_S), ros_A(ros_S*(ros_S-1)/2),  
     &     ros_Gamma(ros_S), ros_C(ros_S*(ros_S-1)/2), ros_ELO
      LOGICAL, INTENT(IN) :: ros_NewF(ros_S)
C~~~  > Input: integration parameters   
      LOGICAL, INTENT(IN) :: Autonomous, VectorTol
      INTEGER, INTENT(IN) :: AdjointType
      REAL(kind=dp), INTENT(IN) :: Hstart, Hmin, Hmax
      INTEGER, INTENT(IN) :: Max_no_steps
      REAL(kind=dp), INTENT(IN) :: Roundoff, FacMin, FacMax, FacRej, FacSafe 
C~~~  > Output: last accepted step   
      REAL(kind=dp), INTENT(OUT) :: Hexit 
C~~~  > Output: Error indicator
      INTEGER, INTENT(OUT) :: IERR
C     ~~~~ Local variables        
      REAL(kind=dp) :: Y0(KPPNSP)
      REAL(kind=dp) :: Ynew(KPPNSP,NADJ), Fcn0(KPPNSP,NADJ), Fcn(KPPNSP,NADJ) 
      REAL(kind=dp) :: K(KPPNSP*ros_S,NADJ), dFdT(KPPNSP,NADJ)
      REAL(kind=dp) :: Jac0(LU_NONZERO), Ghimj(LU_NONZERO)
      REAL(kind=dp) :: Jac(LU_NONZERO), dJdT(LU_NONZERO)
      REAL(kind=dp) :: H, Hnew, HC, HG, Fac, Tau 
      REAL(kind=dp) :: Err, Yerr(KPPNSP,NADJ)
      INTEGER :: Pivot(KPPNSP), Direction, ioffset, i, j, istage, iadj
      LOGICAL :: RejectLastH, RejectMoreH, Singular
C~~~  >  Local parameters
      REAL(kind=dp), PARAMETER :: ZERO = 0.0d0, ONE  = 1.0d0 
      REAL(kind=dp), PARAMETER :: DeltaMin = 1.0d-5
C~~~  >  Locally called functions
C     REAL(kind=dp) WLAMCH
C     EXTERNAL WLAMCH
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      REAL(kind=dp) :: RKI(KPPNRCT)

      
C~~~  >  INITIAL PREPARATIONS
      T = Tstart
      Hexit = 0.0_dp
      H = MIN(Hstart,Hmax) 
      IF (ABS(H) <= 10.0_dp*Roundoff) H = DeltaMin
      
      IF (Tend  >=  Tstart) THEN
         Direction = +1
      ELSE
         Direction = -1
      END IF               

      RejectLastH=.FALSE.
      RejectMoreH=.FALSE.
      
      OPEN(55,file='CMAQ_CB4_full_cadj.dat')
      
C~~~  > Time loop begins below 

      TimeLoop: DO WHILE ( (Direction > 0).AND.((T-Tend)+Roundoff <= ZERO)  
     &     .OR. (Direction < 0).AND.((Tend-T)+Roundoff <= ZERO) ) 
      
      IF ( Nstp > Max_no_steps ) THEN ! Too many steps
         CALL ros_ErrorMsg(-6,T,H,IERR)
         RETURN
      END IF
      IF ( ((T+0.1d0*H) == T).OR.(H <= Roundoff) ) THEN ! Step size too small
         CALL ros_ErrorMsg(-7,T,H,IERR)
         RETURN
      END IF
      
C~~~  >  Limit H if necessary to avoid going beyond Tend   
      Hexit = H
      H = MIN(H,ABS(Tend-T))

C~~~  >   Interpolate forward solution
      CALL ros_cadj_Y( T, Y0 )     
C~~~  >   Compute the Jacobian at current time
      CALL JacTemplate(Y0, RKI, Jac0)

      WRITE(55,55) T, H, Y0(ind_NO2), Y0(ind_O3),  
     &     Y(ind_NO2,1), Y(ind_O3,2),              
     &     Y(ind_NO2,2), Y(ind_O3,1)
      
C~~~  >  Compute the function derivative with respect to T
      IF (.NOT.Autonomous) THEN
         CALL ros_JacTimeDerivative ( T, Roundoff, Y0,  
     &        Jac0, dJdT )
         DO iadj = 1, NADJ
            CALL JacTR_SP_Vec(dJdT,Y(1,iadj),dFdT(1,iadj))
            CALL WSCAL(KPPNSP,(-ONE),dFdT(1,iadj),1)
         END DO
      END IF

C~~~  >  Ydot = -J^T*Y
      CALL WSCAL(LU_NONZERO,(-ONE),Jac0,1)
      DO iadj = 1, NADJ
         CALL JacTR_SP_Vec(Jac0,Y(1,iadj),Fcn0(1,iadj))
      END DO
      
C~~~  >  Repeat step calculation until current step accepted
      UntilAccepted: DO  
      
      CALL ros_PrepareMatrix(H,Direction,ros_Gamma(1),  
     &     Jac0,Ghimj,Pivot,Singular)
      IF (Singular) THEN        ! More than 5 consecutive failed decompositions
         CALL ros_ErrorMsg(-8,T,H,IERR)
         RETURN
      END IF

C~~~  >   Compute the stages
      Stage: DO istage = 1, ros_S
      
                                ! Current istage offset. Current istage vector is K(ioffset+1:ioffset+KPPNSP)
      ioffset = KPPNSP*(istage-1)
      
                                ! For the 1st istage the function has been computed previously
      IF ( istage == 1 ) THEN
         DO iadj = 1, NADJ
            CALL WCOPY(KPPNSP,Fcn0(1,iadj),1,Fcn(1,iadj),1)
         END DO
                                ! istage>1 and a new function evaluation is needed at the current istage
      ELSEIF ( ros_NewF(istage) ) THEN
         CALL WCOPY(KPPNSP*NADJ,Y,1,Ynew,1)
         DO j = 1, istage-1
            DO iadj = 1, NADJ
               CALL WAXPY(KPPNSP,ros_A((istage-1)*(istage-2)/2+j),  
     &              K(KPPNSP*(j-1)+1,iadj),1,Ynew(1,iadj),1) 
            END DO       
         END DO
         Tau = T + ros_Alpha(istage)*Direction*H
                                ! CALL FunTemplate(Tau,Ynew,Fcn)
         CALL ros_cadj_Y( Tau, Y0 )     
         CALL JacTemplate(Y0, RKI, Jac)
         CALL WSCAL(LU_NONZERO,(-ONE),Jac,1)
         DO iadj = 1, NADJ
            CALL JacTR_SP_Vec(Jac,Ynew(1,iadj),Fcn(1,iadj))
                                !CALL WSCAL(KPPNSP,(-ONE),Fcn(1,iadj),1)
         END DO
      END IF                    ! if istage == 1 elseif ros_NewF(istage)

      DO iadj = 1, NADJ
         CALL WCOPY(KPPNSP,Fcn(1,iadj),1,K(ioffset+1,iadj),1)
      END DO
      DO j = 1, istage-1
         HC = ros_C((istage-1)*(istage-2)/2+j)/(Direction*H)
         DO iadj = 1, NADJ
            CALL WAXPY(KPPNSP,HC,K(KPPNSP*(j-1)+1,iadj),1,  
     &           K(ioffset+1,iadj),1)
         END DO
      END DO
      IF ((.NOT. Autonomous).AND.(ros_Gamma(istage).NE.ZERO)) THEN
         HG = Direction*H*ros_Gamma(istage)
         DO iadj = 1, NADJ
            CALL WAXPY(KPPNSP,HG,dFdT(1,iadj),1,K(ioffset+1,iadj),1)
         END DO
      END IF
      DO iadj = 1, NADJ
         CALL ros_Solve('T', Ghimj, Pivot, K(ioffset+1,iadj))
      END DO
      
      END DO Stage     
      

C~~~  >  Compute the new solution 
      DO iadj = 1, NADJ
         CALL WCOPY(KPPNSP,Y(1,iadj),1,Ynew(1,iadj),1)
         DO j=1,ros_S
            CALL WAXPY(KPPNSP,ros_M(j),K(KPPNSP*(j-1)+1,iadj),1,Ynew(1,iadj),1)
         END DO
      END DO

C~~~  >  Compute the error estimation 
      CALL WSCAL(KPPNSP*NADJ,ZERO,Yerr,1)
      DO j=1,ros_S     
         DO iadj = 1, NADJ
            CALL WAXPY(KPPNSP,ros_E(j),K(KPPNSP*(j-1)+1,iadj),1,Yerr(1,iadj),1)
         END DO
      END DO
C~~~  > Max error among all adjoint components    
      iadj = 1
      Err = ros_ErrorNorm ( Y(1,iadj), Ynew(1,iadj), Yerr(1,iadj),  
     &     AbsTol, RelTol, VectorTol )

C~~~  > New step size is bounded by FacMin <= Hnew/H <= FacMax
      Fac  = MIN(FacMax,MAX(FacMin,FacSafe/Err**(ONE/ros_ELO)))
      Hnew = H*Fac  

C~~~  >  Check the error magnitude and adjust step size
      Nstp = Nstp+1
      IF ( (Err <= ONE).OR.(H <= Hmin) ) THEN !~~~> Accept step
         Nacc = Nacc+1
         CALL WCOPY(KPPNSP*NADJ,Ynew,1,Y,1)
         T = T + Direction*H
         Hnew = MAX(Hmin,MIN(Hnew,Hmax))
         IF (RejectLastH) THEN  ! No step size increase after a rejected step
            Hnew = MIN(Hnew,H) 
         END IF   
         RejectLastH = .FALSE.  
         RejectMoreH = .FALSE.
         H = Hnew      
         EXIT UntilAccepted     ! EXIT THE LOOP: WHILE STEP NOT ACCEPTED
      ELSE                      !~~~> Reject step
         IF (RejectMoreH) THEN
            Hnew = H*FacRej
         END IF   
         RejectMoreH = RejectLastH
         RejectLastH = .TRUE.
         H = Hnew
         IF (Nacc >= 1) THEN
            Nrej = Nrej+1
         END IF    
      END IF                    ! Err <= 1

      END DO UntilAccepted 

      END DO TimeLoop 
      
C~~~  > Succesful exit
      IERR = 1                  !~~~> The integration was successful

      WRITE(55,55) T, H, Y0(ind_NO2), Y0(ind_O3),  
     &     Y(ind_NO2,1), Y(ind_O3,2),      
     &     Y(ind_NO2,2), Y(ind_O3,1)
      
 55   FORMAT(100(E12.5,2X))
      CLOSE(55)

      END SUBROUTINE ros_CadjInt
      
      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_SimpleCadjInt (                   
     &     NADJ, Y,                                  
     &     Tstart, Tend, T,                          
     &     AbsTol, RelTol,                           
C~~~  > RosenbrockADJ method coefficients     
     &     ros_S, ros_M, ros_E, ros_A, ros_C,        
     &     ros_Alpha, ros_Gamma, ros_ELO, ros_NewF,  
C~~~  > Integration parameters
     &     Autonomous, VectorTol, AdjointType,       
     &     Max_no_steps,                             
     &     Roundoff, Hmin, Hmax, Hstart,             
     &     FacMin, FacMax, FacRej, FacSafe,          
C~~~  > Error indicator
     &     IERR, RKI )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     Template for the implementation of a generic RosenbrockADJ method 
C     defined by ros_S (no of stages)  
C     and its coefficients ros_{A,C,M,E,Alpha,Gamma}
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      IMPLICIT NONE
      
C~~~  > Input: the initial condition at Tstart; Output: the solution at T   
      INTEGER, INTENT(IN) :: NADJ
      REAL(kind=dp), INTENT(INOUT) :: Y(KPPNSP,NADJ)
C~~~  > Input: integration interval   
      REAL(kind=dp), INTENT(IN) :: Tstart,Tend      
C~~~  > Output: time at which the solution is returned (T=Tend if success)   
      REAL(kind=dp), INTENT(OUT) ::  T      
C~~~  > Input: tolerances      
      REAL(kind=dp), INTENT(IN) ::  AbsTol(KPPNSP), RelTol(KPPNSP)
C~~~  > Input: The RosenbrockADJ method parameters   
      INTEGER, INTENT(IN) ::  ros_S
      REAL(kind=dp), INTENT(IN) :: ros_M(ros_S), ros_E(ros_S),    
     &     ros_Alpha(ros_S), ros_A(ros_S*(ros_S-1)/2),       
     &     ros_Gamma(ros_S), ros_C(ros_S*(ros_S-1)/2), ros_ELO
      LOGICAL, INTENT(IN) :: ros_NewF(ros_S)
C~~~  > Input: integration parameters   
      LOGICAL, INTENT(IN) :: Autonomous, VectorTol
      INTEGER, INTENT(IN) :: AdjointType
      REAL(kind=dp), INTENT(IN) :: Hstart, Hmin, Hmax
      INTEGER, INTENT(IN) :: Max_no_steps
      REAL(kind=dp), INTENT(IN) :: Roundoff, FacMin, FacMax, FacRej, FacSafe 
C~~~  > Output: Error indicator
      INTEGER, INTENT(OUT) :: IERR
C     ~~~~ Local variables        
      REAL(kind=dp) :: Y0(KPPNSP), Y0old(KPPNSP), Told
      REAL(kind=dp) :: Ynew(KPPNSP,NADJ), Fcn0(KPPNSP,NADJ), Fcn(KPPNSP,NADJ) 
      REAL(kind=dp) :: K(KPPNSP*ros_S,NADJ), dFdT(KPPNSP,NADJ)
      REAL(kind=dp) :: Jac0(LU_NONZERO), Ghimj(LU_NONZERO)
      REAL(kind=dp) :: Jac(LU_NONZERO), dJdT(LU_NONZERO)
      REAL(kind=dp) :: H, Hnew, HC, HG, Fac, Tau 
      REAL(kind=dp) :: Err, ghinv
      INTEGER :: Pivot(KPPNSP), Direction, ioffset, i, j, istage, iadj
      INTEGER :: istack
      LOGICAL :: RejectLastH, RejectMoreH, Singular
C~~~  >  Local parameters
      REAL(kind=dp), PARAMETER :: ZERO = 0.0d0, ONE  = 1.0d0 
      REAL(kind=dp), PARAMETER :: DeltaMin = 1.0d-5
C~~~  >  Locally called functions
C     REAL(kind=dp) WLAMCH
C     EXTERNAL WLAMCH
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      REAL(kind=dp) :: RKI(KPPNRCT)

      
C~~~  >  INITIAL PREPARATIONS
      
      IF (Tend  >=  Tstart) THEN
         Direction = -1
      ELSE
         Direction = +1
      END IF               

      OPEN(55,file='CMAQ_CB4_smpl_cadj.dat')

      
C~~~  > Time loop begins below 
      TimeLoop: DO istack = stack_ptr,2,-1
      
      T = buf_T(istack)
      H = buf_H(istack-1)
      CALL WCOPY(KPPNSP,buf_Y(1:KPPNSP,istack),1,Y0,1)
      
      WRITE(55,55) T, H, Y0(ind_NO2), Y0(ind_O3),  
     &     Y(ind_NO2,1), Y(ind_O3,2), Y(ind_NO2,2), Y(ind_O3,1)
      
C~~~  >   Compute the Jacobian at current time
      CALL JacTemplate(Y0, RKI, Jac0)
      
C~~~  >  Compute the function derivative with respect to T
      IF (.NOT.Autonomous) THEN
         CALL ros_JacTimeDerivative ( T, Roundoff, Y0,  
     &        Jac0, dJdT )
         DO iadj = 1, NADJ
            CALL JacTR_SP_Vec(dJdT,Y(1,iadj),dFdT(1,iadj))
            CALL WSCAL(KPPNSP,(-ONE),dFdT(1,iadj),1)
         END DO
      END IF

C~~~  >  Ydot = -J^T*Y
      CALL WSCAL(LU_NONZERO,(-ONE),Jac0,1)
      DO iadj = 1, NADJ
         CALL JacTR_SP_Vec(Jac0,Y(1,iadj),Fcn0(1,iadj))
      END DO
      
C~~~  >    Construct Ghimj = 1/(H*ham) - Jac0
      CALL WCOPY(LU_NONZERO,Jac0,1,Ghimj,1)
      CALL WSCAL(LU_NONZERO,(-ONE),Ghimj,1)
      ghinv = ONE/(Direction*H*ros_Gamma(1))
      DO i=1,KPPNSP
         Ghimj(LU_DIAG(i)) = Ghimj(LU_DIAG(i))+ghinv
      END DO
C~~~  >    Compute LU decomposition 
      CALL ros_Decomp( Ghimj, Pivot, j )
      IF (j /= 0) THEN
         CALL ros_ErrorMsg(-8,T,H,IERR)
         PRINT*,' The matrix is singular !'
         STOP
      END IF

C~~~  >   Compute the stages
      Stage: DO istage = 1, ros_S
      
                                ! Current istage offset. Current istage vector is K(ioffset+1:ioffset+KPPNSP)
      ioffset = KPPNSP*(istage-1)
      
                                ! For the 1st istage the function has been computed previously
      IF ( istage == 1 ) THEN
         DO iadj = 1, NADJ
            CALL WCOPY(KPPNSP,Fcn0(1,iadj),1,Fcn(1,iadj),1)
         END DO
                                ! istage>1 and a new function evaluation is needed at the current istage
      ELSEIF ( ros_NewF(istage) ) THEN
         CALL WCOPY(KPPNSP*NADJ,Y,1,Ynew,1)
         DO j = 1, istage-1
            DO iadj = 1, NADJ
               CALL WAXPY(KPPNSP,ros_A((istage-1)*(istage-2)/2+j),  
     &              K(KPPNSP*(j-1)+1,iadj),1,Ynew(1,iadj),1) 
            END DO       
         END DO
         Tau = T + ros_Alpha(istage)*Direction*H
         CALL ros_Hermite3( buf_T(istack-1), buf_T(istack), Tau,
     &        buf_Y(1:KPPNSP,istack-1), buf_Y(1:KPPNSP,istack),
     &        buf_dY(1:KPPNSP,istack-1), buf_dY(1:KPPNSP,istack), Y0 )
         CALL JacTemplate(Y0, RKI, Jac)
         CALL WSCAL(LU_NONZERO,(-ONE),Jac,1)
         DO iadj = 1, NADJ
            CALL JacTR_SP_Vec(Jac,Ynew(1,iadj),Fcn(1,iadj))
         END DO
      END IF                    ! if istage == 1 elseif ros_NewF(istage)

      DO iadj = 1, NADJ
         CALL WCOPY(KPPNSP,Fcn(1,iadj),1,K(ioffset+1,iadj),1)
      END DO
      DO j = 1, istage-1
         HC = ros_C((istage-1)*(istage-2)/2+j)/(Direction*H)
         DO iadj = 1, NADJ
            CALL WAXPY(KPPNSP,HC,K(KPPNSP*(j-1)+1,iadj),1,  
     &           K(ioffset+1,iadj),1)
         END DO
      END DO
      IF ((.NOT. Autonomous).AND.(ros_Gamma(istage).NE.ZERO)) THEN
         HG = Direction*H*ros_Gamma(istage)
         DO iadj = 1, NADJ
            CALL WAXPY(KPPNSP,HG,dFdT(1,iadj),1,K(ioffset+1,iadj),1)
         END DO
      END IF
      DO iadj = 1, NADJ
         CALL ros_Solve('T', Ghimj, Pivot, K(ioffset+1,iadj))
      END DO
      
      END DO Stage     
      

C~~~  >  Compute the new solution 
      DO iadj = 1, NADJ
         DO j=1,ros_S
            CALL WAXPY(KPPNSP,ros_M(j),K(KPPNSP*(j-1)+1,iadj),1,Y(1,iadj),1)
         END DO
      END DO

      END DO TimeLoop 
      
C~~~  > Succesful exit
      IERR = 1                  !~~~> The integration was successful

      WRITE(55,55) T, H, Y0(ind_NO2), Y0(ind_O3),  
     &     Y(ind_NO2,1), Y(ind_O3,2),                
     &     Y(ind_NO2,2), Y(ind_O3,1)
      
 55   FORMAT(100(E12.5,2X))
      CLOSE(55)

      END SUBROUTINE ros_SimpleCadjInt
      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      REAL(kind=dp) FUNCTION ros_ErrorNorm ( Y, Ynew, Yerr,   
     &     AbsTol, RelTol, VectorTol )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C~~~  > Computes the "scaled norm" of the error vector Yerr
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      IMPLICIT NONE         

C     Input arguments   
      REAL(kind=dp), INTENT(IN) :: Y(KPPNSP), Ynew(KPPNSP),  
     &     Yerr(KPPNSP), AbsTol(KPPNSP), RelTol(KPPNSP)
      LOGICAL, INTENT(IN) ::  VectorTol
C     Local variables     
      REAL(kind=dp) :: Err, Scale, Ymax   
      INTEGER  :: i
      REAL(kind=dp), PARAMETER :: ZERO = 0.0d0
      
      Err = ZERO
      DO i=1,KPPNSP
         Ymax = MAX(ABS(Y(i)),ABS(Ynew(i)))
         IF (VectorTol) THEN
            Scale = AbsTol(i)+RelTol(i)*Ymax
         ELSE
            Scale = AbsTol(1)+RelTol(1)*Ymax
         END IF
         Err = Err+(Yerr(i)/Scale)**2
      END DO
      Err  = SQRT(Err/KPPNSP)
      
      ros_ErrorNorm = Err
      
      END FUNCTION ros_ErrorNorm


C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_FunTimeDerivative ( T, Roundoff, Y, Fcn0, dFdT )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C~~~  > The time partial derivative of the function by finite differences
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      IMPLICIT NONE         

C~~~  > Input arguments   
      REAL(kind=dp), INTENT(IN) :: T, Roundoff, Y(KPPNSP), Fcn0(KPPNSP) 
C~~~  > Output arguments   
      REAL(kind=dp), INTENT(OUT) :: dFdT(KPPNSP)   
C~~~  > Local variables     
      REAL(kind=dp) :: Delta  
      REAL(kind=dp), PARAMETER :: ONE = 1.0d0, DeltaMin = 1.0d-6
      
      Delta = SQRT(Roundoff)*MAX(DeltaMin,ABS(T))
C     CALL FunTemplate(T+Delta,Y,dFdT)
      CALL WAXPY(KPPNSP,(-ONE),Fcn0,1,dFdT,1)
      CALL WSCAL(KPPNSP,(ONE/Delta),dFdT,1)

      END SUBROUTINE ros_FunTimeDerivative


C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_JacTimeDerivative ( T, Roundoff, Y,  
     &     Jac0, dJdT )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C~~~  > The time partial derivative of the Jacobian by finite differences
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      IMPLICIT NONE         

C~~~  > Input arguments   
      REAL(kind=dp), INTENT(IN) :: T, Roundoff, Y(KPPNSP), Jac0(LU_NONZERO) 
C~~~  > Output arguments   
      REAL(kind=dp), INTENT(OUT) :: dJdT(LU_NONZERO)   
C~~~  > Local variables     
      REAL(kind=dp) Delta  
      REAL(kind=dp), PARAMETER :: ONE = 1.0d0, DeltaMin = 1.0d-6
      
      Delta = SQRT(Roundoff)*MAX(DeltaMin,ABS(T))
C     CALL JacTemplate(T+Delta,Y,dJdT)
      CALL WAXPY(LU_NONZERO,(-ONE),Jac0,1,dJdT,1)
      CALL WSCAL(LU_NONZERO,(ONE/Delta),dJdT,1)

      END SUBROUTINE ros_JacTimeDerivative


C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_PrepareMatrix ( H, Direction, gam,  
     &     Jac0, Ghimj, Pivot, Singular )
C     --- --- --- --- --- --- --- --- --- --- --- --- ---
C     Prepares the LHS matrix for stage calculations
C     1.  Construct Ghimj = 1/(H*ham) - Jac0
C     "(Gamma H) Inverse Minus Jacobian"
C     2.  Repeat LU decomposition of Ghimj until successful.
C     -half the step size if LU decomposition fails and retry
C     -exit after 5 consecutive fails
C     --- --- --- --- --- --- --- --- --- --- --- --- ---
      IMPLICIT NONE         
      
C~~~  > Input arguments   
      REAL(kind=dp), INTENT(IN) ::  gam, Jac0(LU_NONZERO)
      INTEGER, INTENT(IN) ::  Direction
C~~~  > Output arguments   
      REAL(kind=dp), INTENT(OUT) :: Ghimj(LU_NONZERO)
      LOGICAL, INTENT(OUT) ::  Singular
      INTEGER, INTENT(OUT) ::  Pivot(KPPNSP)
C~~~  > Inout arguments   
      REAL(kind=dp), INTENT(INOUT) :: H ! step size is decreased when LU fails
C~~~  > Local variables     
      INTEGER  :: i, ising, Nconsecutive
      REAL(kind=dp) ::  ghinv
      REAL(kind=dp), PARAMETER :: ONE  = 1.0d0, HALF = 0.5d0
      
      Nconsecutive = 0
      Singular = .TRUE.
      
      DO WHILE (Singular)
         
C~~~  >    Construct Ghimj = 1/(H*ham) - Jac0
         CALL WCOPY(LU_NONZERO,Jac0,1,Ghimj,1)
         CALL WSCAL(LU_NONZERO,(-ONE),Ghimj,1)
         ghinv = ONE/(Direction*H*gam)
         DO i=1,KPPNSP
            Ghimj(LU_DIAG(i)) = Ghimj(LU_DIAG(i))+ghinv
         END DO
C~~~  >    Compute LU decomposition 
         CALL ros_Decomp( Ghimj, Pivot, ising )
         IF (ising == 0) THEN
C~~~  >    If successful done 
            Singular = .FALSE. 
         ELSE                   ! ising .ne. 0
C~~~  >    If unsuccessful half the step size; if 5 consecutive fails then return
            Nsng = Nsng+1
            Nconsecutive = Nconsecutive+1
            Singular = .TRUE. 
            PRINT*,'Warning: LU Decomposition returned ising = ',ising
            IF (Nconsecutive <= 5) THEN ! Less than 5 consecutive failed decompositions
               H = H*HALF
            ELSE                ! More than 5 consecutive failed decompositions
               RETURN
            END IF              ! Nconsecutive
         END IF                 ! ising 
         
      END DO                    ! WHILE Singular
      
      END SUBROUTINE ros_PrepareMatrix

      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_Decomp( A, Pivot, ising )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     Template for the LU decomposition   
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      IMPLICIT NONE
C~~~  > Inout variables     
      REAL(kind=dp), INTENT(INOUT) :: A(LU_NONZERO)
C~~~  > Output variables     
      INTEGER, INTENT(OUT) :: Pivot(KPPNSP), ising
      
      CALL KppDecomp ( A, ising )
C~~~  > Note: for a full matrix use Lapack:
C     CALL  DGETRF( KPPNSP, KPPNSP, A, KPPNSP, Pivot, ising ) 
      Pivot(1) = 1
      
      Ndec = Ndec + 1

      END SUBROUTINE ros_Decomp
      
      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_Solve( C, A, Pivot, b )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     Template for the forward/backward substitution (using pre-computed LU decomposition)   
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      IMPLICIT NONE
C~~~  > Input variables 
      CHARACTER, INTENT(IN) :: C    
      REAL(kind=dp), INTENT(IN) :: A(LU_NONZERO)
      INTEGER, INTENT(IN) :: Pivot(KPPNSP)
C~~~  > InOut variables     
      REAL(kind=dp), INTENT(INOUT) :: b(KPPNSP)
      
      SELECT CASE (C)
      CASE ('N')
         CALL KppSolve( A, b )
      CASE ('T')
         CALL KppSolveTR( A, b, b )
      CASE DEFAULT
         PRINT*,'Unknown C = (',C,') in ros_Solve'
         STOP
      END SELECT
C~~~  > Note: for a full matrix use Lapack:
C     NRHS = 1
C     CALL  DGETRS( C, KPPNSP , NRHS, A, KPPNSP, Pivot, b, KPPNSP, INFO )
      
      Nsol = Nsol+1

      END SUBROUTINE ros_Solve
      

C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_cadj_Y( T, Y )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     Finds the solution Y at T by interpolating the stored forward trajectory
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      IMPLICIT NONE
C~~~  > Input variables 
      REAL(kind=dp), INTENT(IN) :: T
C~~~  > Output variables     
      REAL(kind=dp), INTENT(OUT) :: Y(KPPNSP)
C~~~  > Local variables     
      INTEGER     :: i, j
      REAL(kind=dp), PARAMETER  :: ONE = 1.0d0

C     buf_H, buf_T, buf_Y, buf_dY, buf_d2Y

      IF( (T < buf_T(1)).OR.(T> buf_T(stack_ptr)) ) THEN
         PRINT*,'Cannot locate solution at T = ',T
         PRINT*,'Stored trajectory is between Tstart = ',buf_T(1)
         PRINT*,'    and Tend = ',buf_T(stack_ptr)
         STOP
      END IF
      DO i = 1, stack_ptr-1
         IF( (T>= buf_T(i)).AND.(T<= buf_T(i+1)) ) EXIT
      END DO 


      IF (.FALSE.) THEN

         CALL ros_Hermite5( buf_T(i), buf_T(i+1), T,
     &        buf_Y(1:KPPNSP,i),   buf_Y(1:KPPNSP,i+1),
     &        buf_dY(1:KPPNSP,i),  buf_dY(1:KPPNSP,i+1),
     &        buf_d2Y(1:KPPNSP,i), buf_d2Y(1:KPPNSP,i+1), Y )
         
      ELSE
         
         CALL ros_Hermite3( buf_T(i), buf_T(i+1), T,
     &        buf_Y(1:KPPNSP,i),   buf_Y(1:KPPNSP,i+1),
     &        buf_dY(1:KPPNSP,i),  buf_dY(1:KPPNSP,i+1),
     &        Y )
         
         
      END IF       

      END SUBROUTINE ros_cadj_Y
      

C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_Hermite3( a, b, T, Ya, Yb, Ja, Jb, Y )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     Template for Hermite interpolation of order 5 on the interval [a,b]
C     P = c(1) + c(2)*(x-a) + ... + c(4)*(x-a)^3
C     P[a,b] = [Ya,Yb], P'[a,b] = [Ja,Jb]
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      IMPLICIT NONE
C~~~  > Input variables 
      REAL(kind=dp), INTENT(IN) :: a, b, T, Ya(KPPNSP), Yb(KPPNSP)
      REAL(kind=dp), INTENT(IN) :: Ja(KPPNSP), Jb(KPPNSP)
C~~~  > Output variables     
      REAL(kind=dp), INTENT(OUT) :: Y(KPPNSP)
C~~~  > Local variables     
      REAL(kind=dp) :: Tau, amb(3), C(KPPNSP,4)
      REAL(kind=dp), PARAMETER :: ZERO = 0.0d0
      INTEGER :: i, j
      
      amb(1) = 1.0d0/(a-b)
      DO i=2,3
         amb(i) = amb(i-1)*amb(1)
      END DO
      
      
C     c(1) = ya;
      CALL WCOPY(KPPNSP,Ya,1,C(1,1),1)
C     c(2) = ja;
      CALL WCOPY(KPPNSP,Ja,1,C(1,2),1)
C     c(3) = 2/(a-b)*ja + 1/(a-b)*jb - 3/(a - b)^2*ya + 3/(a - b)^2*yb  ;
      CALL WCOPY(KPPNSP,Ya,1,C(1,3),1)
      CALL WSCAL(KPPNSP,-3.0*amb(2),C(1,3),1)
      CALL WAXPY(KPPNSP,3.0*amb(2),Yb,1,C(1,3),1)
      CALL WAXPY(KPPNSP,2.0*amb(1),Ja,1,C(1,3),1)
      CALL WAXPY(KPPNSP,amb(1),Jb,1,C(1,3),1)
C     c(4) =  1/(a-b)^2*ja + 1/(a-b)^2*jb - 2/(a-b)^3*ya + 2/(a-b)^3*yb ;
      CALL WCOPY(KPPNSP,Ya,1,C(1,4),1)
      CALL WSCAL(KPPNSP,-2.0*amb(3),C(1,4),1)
      CALL WAXPY(KPPNSP,2.0*amb(3),Yb,1,C(1,4),1)
      CALL WAXPY(KPPNSP,amb(2),Ja,1,C(1,4),1)
      CALL WAXPY(KPPNSP,amb(2),Jb,1,C(1,4),1)
      
      Tau = T - a
      CALL WCOPY(KPPNSP,C(1,4),1,Y,1)
      CALL WSCAL(KPPNSP,Tau**3,Y,1)
      DO j = 3,1,-1
         CALL WAXPY(KPPNSP,TAU**(j-1),C(1,j),1,Y,1)
      END DO       

      END SUBROUTINE ros_Hermite3

C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE ros_Hermite5( a, b, T, Ya, Yb, Ja, Jb, Ha, Hb, Y )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     Template for Hermite interpolation of order 5 on the interval [a,b]
C     P = c(1) + c(2)*(x-a) + ... + c(6)*(x-a)^5
C     P[a,b] = [Ya,Yb], P'[a,b] = [Ja,Jb], P"[a,b] = [Ha,Hb]
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      IMPLICIT NONE
C~~~  > Input variables 
      REAL(kind=dp), INTENT(IN) :: a, b, T, Ya(KPPNSP), Yb(KPPNSP)
      REAL(kind=dp), INTENT(IN) :: Ja(KPPNSP), Jb(KPPNSP), Ha(KPPNSP), Hb(KPPNSP)
C~~~  > Output variables     
      REAL(kind=dp), INTENT(OUT) :: Y(KPPNSP)
C~~~  > Local variables     
      REAL(kind=dp) :: Tau, amb(5), C(KPPNSP,6)
      REAL(kind=dp), PARAMETER :: ZERO = 0.0d0, HALF = 0.5d0
      INTEGER :: i, j
      
      amb(1) = 1.0d0/(a-b)
      DO i=2,5
         amb(i) = amb(i-1)*amb(1)
      END DO
      
C     c(1) = ya;
      CALL WCOPY(KPPNSP,Ya,1,C(1,1),1)
C     c(2) = ja;
      CALL WCOPY(KPPNSP,Ja,1,C(1,2),1)
C     c(3) = ha/2;
      CALL WCOPY(KPPNSP,Ha,1,C(1,3),1)
      CALL WSCAL(KPPNSP,HALF,C(1,3),1)
      
C     c(4) = 10*amb(3)*ya - 10*amb(3)*yb - 6*amb(2)*ja - 4*amb(2)*jb  + 1.5*amb(1)*ha - 0.5*amb(1)*hb ;
      CALL WCOPY(KPPNSP,Ya,1,C(1,4),1)
      CALL WSCAL(KPPNSP,10.0*amb(3),C(1,4),1)
      CALL WAXPY(KPPNSP,-10.0*amb(3),Yb,1,C(1,4),1)
      CALL WAXPY(KPPNSP,-6.0*amb(2),Ja,1,C(1,4),1)
      CALL WAXPY(KPPNSP,-4.0*amb(2),Jb,1,C(1,4),1)
      CALL WAXPY(KPPNSP, 1.5*amb(1),Ha,1,C(1,4),1)
      CALL WAXPY(KPPNSP,-0.5*amb(1),Hb,1,C(1,4),1)

C     c(5) =   15*amb(4)*ya - 15*amb(4)*yb - 8.*amb(3)*ja - 7*amb(3)*jb + 1.5*amb(2)*ha - 1*amb(2)*hb ;
      CALL WCOPY(KPPNSP,Ya,1,C(1,5),1)
      CALL WSCAL(KPPNSP, 15.0*amb(4),C(1,5),1)
      CALL WAXPY(KPPNSP,-15.0*amb(4),Yb,1,C(1,5),1)
      CALL WAXPY(KPPNSP,-8.0*amb(3),Ja,1,C(1,5),1)
      CALL WAXPY(KPPNSP,-7.0*amb(3),Jb,1,C(1,5),1)
      CALL WAXPY(KPPNSP,1.5*amb(2),Ha,1,C(1,5),1)
      CALL WAXPY(KPPNSP,-amb(2),Hb,1,C(1,5),1)
      
C     c(6) =   6*amb(5)*ya - 6*amb(5)*yb - 3.*amb(4)*ja - 3.*amb(4)*jb + 0.5*amb(3)*ha -0.5*amb(3)*hb ;
      CALL WCOPY(KPPNSP,Ya,1,C(1,6),1)
      CALL WSCAL(KPPNSP, 6.0*amb(5),C(1,6),1)
      CALL WAXPY(KPPNSP,-6.0*amb(5),Yb,1,C(1,6),1)
      CALL WAXPY(KPPNSP,-3.0*amb(4),Ja,1,C(1,6),1)
      CALL WAXPY(KPPNSP,-3.0*amb(4),Jb,1,C(1,6),1)
      CALL WAXPY(KPPNSP, 0.5*amb(3),Ha,1,C(1,6),1)
      CALL WAXPY(KPPNSP,-0.5*amb(3),Hb,1,C(1,6),1)
      
      Tau = T - a
      CALL WCOPY(KPPNSP,C(1,6),1,Y,1)
      DO j = 5,1,-1
         CALL WSCAL(KPPNSP,Tau,Y,1)
         CALL WAXPY(KPPNSP,ONE,C(1,j),1,Y,1)
      END DO       

      END SUBROUTINE ros_Hermite5
      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE Ros2 (ros_S,ros_A,ros_C,ros_M,ros_E,ros_Alpha, 
     &     ros_Gamma,ros_NewF,ros_ELO,ros_Name)
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     --- AN L-STABLE METHOD, 2 stages, order 2
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      IMPLICIT NONE
      
      INTEGER, PARAMETER :: S = 2
      INTEGER, INTENT(OUT) ::  ros_S
      REAL(kind=dp), DIMENSION(S), INTENT(OUT) :: ros_M,ros_E,ros_Alpha,ros_Gamma
      REAL(kind=dp), DIMENSION(S*(S-1)/2), INTENT(OUT) :: ros_A, ros_C
      REAL(kind=dp), INTENT(OUT) :: ros_ELO
      LOGICAL, DIMENSION(S), INTENT(OUT) :: ros_NewF
      CHARACTER(LEN=12), INTENT(OUT) :: ros_Name
      DOUBLE PRECISION g
      
      g = 1.0d0 + 1.0d0/SQRT(2.0d0)
      
C~~~  > Name of the method
      ros_Name = 'ROS-2'   
C~~~  > Number of stages
      ros_S = S
      
C~~~  > The coefficient matrices A and C are strictly lower triangular.
C     The lower triangular (subdiagonal) elements are stored in row-wise order:
C     A(2,1) = ros_A(1), A(3,1)=ros_A(2), A(3,2)=ros_A(3), etc.
C     The general mapping formula is:
C     A(i,j) = ros_A( (i-1)*(i-2)/2 + j )    
C     C(i,j) = ros_C( (i-1)*(i-2)/2 + j )  
      
      ros_A(1) = (1.d0)/g
      ros_C(1) = (-2.d0)/g
C~~~  > Does the stage i require a new function evaluation (ros_NewF(i)=TRUE)
C     or does it re-use the function evaluation from stage i-1 (ros_NewF(i)=FALSE)
      ros_NewF(1) = .TRUE.
      ros_NewF(2) = .TRUE.
C~~~  > M_i = Coefficients for new step solution
      ros_M(1)= (3.d0)/(2.d0*g)
      ros_M(2)= (1.d0)/(2.d0*g)
C     E_i = Coefficients for error estimator    
      ros_E(1) = 1.d0/(2.d0*g)
      ros_E(2) = 1.d0/(2.d0*g)
C~~~  > ros_ELO = estimator of local order - the minimum between the
C     main and the embedded scheme orders plus one
      ros_ELO = 2.0d0    
C~~~  > Y_stage_i ~ Y( T + H*Alpha_i )
      ros_Alpha(1) = 0.0d0
      ros_Alpha(2) = 1.0d0 
C~~~  > Gamma_i = \sum_j  gamma_{i,j}    
      ros_Gamma(1) = g
      ros_Gamma(2) =-g
      
      END SUBROUTINE Ros2


C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE Ros3 (ros_S,ros_A,ros_C,ros_M,ros_E,ros_Alpha, 
     &     ros_Gamma,ros_NewF,ros_ELO,ros_Name)
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     --- AN L-STABLE METHOD, 3 stages, order 3, 2 function evaluations
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
      IMPLICIT NONE
      
      INTEGER, PARAMETER :: S = 3
      INTEGER, INTENT(OUT) ::  ros_S
      REAL(kind=dp), DIMENSION(S), INTENT(OUT) :: ros_M,ros_E,ros_Alpha,ros_Gamma
      REAL(kind=dp), DIMENSION(S*(S-1)/2), INTENT(OUT) :: ros_A, ros_C
      REAL(kind=dp), INTENT(OUT) :: ros_ELO
      LOGICAL, DIMENSION(S), INTENT(OUT) :: ros_NewF
      CHARACTER(LEN=12), INTENT(OUT) :: ros_Name
      
C~~~  > Name of the method
      ros_Name = 'ROS-3'   
C~~~  > Number of stages
      ros_S = S
      
C~~~  > The coefficient matrices A and C are strictly lower triangular.
C     The lower triangular (subdiagonal) elements are stored in row-wise order:
C     A(2,1) = ros_A(1), A(3,1)=ros_A(2), A(3,2)=ros_A(3), etc.
C     The general mapping formula is:
C     A(i,j) = ros_A( (i-1)*(i-2)/2 + j )    
C     C(i,j) = ros_C( (i-1)*(i-2)/2 + j )  
      
      ros_A(1)= 1.d0
      ros_A(2)= 1.d0
      ros_A(3)= 0.d0

      ros_C(1) = -0.10156171083877702091975600115545d+01
      ros_C(2) =  0.40759956452537699824805835358067d+01
      ros_C(3) =  0.92076794298330791242156818474003d+01
C~~~  > Does the stage i require a new function evaluation (ros_NewF(i)=TRUE)
C     or does it re-use the function evaluation from stage i-1 (ros_NewF(i)=FALSE)
      ros_NewF(1) = .TRUE.
      ros_NewF(2) = .TRUE.
      ros_NewF(3) = .FALSE.
C~~~  > M_i = Coefficients for new step solution
      ros_M(1) =  0.1d+01
      ros_M(2) =  0.61697947043828245592553615689730d+01
      ros_M(3) = -0.42772256543218573326238373806514d+00
C     E_i = Coefficients for error estimator    
      ros_E(1) =  0.5d+00
      ros_E(2) = -0.29079558716805469821718236208017d+01
      ros_E(3) =  0.22354069897811569627360909276199d+00
C~~~  > ros_ELO = estimator of local order - the minimum between the
C     main and the embedded scheme orders plus 1
      ros_ELO = 3.0d0    
C~~~  > Y_stage_i ~ Y( T + H*Alpha_i )
      ros_Alpha(1)= 0.0d+00
      ros_Alpha(2)= 0.43586652150845899941601945119356d+00
      ros_Alpha(3)= 0.43586652150845899941601945119356d+00
C~~~  > Gamma_i = \sum_j  gamma_{i,j}    
      ros_Gamma(1)= 0.43586652150845899941601945119356d+00
      ros_Gamma(2)= 0.24291996454816804366592249683314d+00
      ros_Gamma(3)= 0.21851380027664058511513169485832d+01

      END SUBROUTINE Ros3

C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE Ros4 (ros_S,ros_A,ros_C,ros_M,ros_E,ros_Alpha, 
     &     ros_Gamma,ros_NewF,ros_ELO,ros_Name)
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     L-STABLE ROSENBROCK METHOD OF ORDER 4, WITH 4 STAGES
C     L-STABLE EMBEDDED ROSENBROCK METHOD OF ORDER 3 
C     
C     E. HAIRER AND G. WANNER, SOLVING ORDINARY DIFFERENTIAL
C     EQUATIONS II. STIFF AND DIFFERENTIAL-ALGEBRAIC PROBLEMS.
C     SPRINGER SERIES IN COMPUTATIONAL MATHEMATICS,
C     SPRINGER-VERLAG (1990)         
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      IMPLICIT NONE
      
      INTEGER, PARAMETER :: S=4
      INTEGER, INTENT(OUT) ::  ros_S
      REAL(kind=dp), DIMENSION(S), INTENT(OUT) :: ros_M,ros_E,ros_Alpha,ros_Gamma
      REAL(kind=dp), DIMENSION(S*(S-1)/2), INTENT(OUT) :: ros_A, ros_C
      REAL(kind=dp), INTENT(OUT) :: ros_ELO
      LOGICAL, DIMENSION(S), INTENT(OUT) :: ros_NewF
      CHARACTER(LEN=12), INTENT(OUT) :: ros_Name
      DOUBLE PRECISION g
      
C~~~  > Name of the method
      ros_Name = 'ROS-4'   
C~~~  > Number of stages
      ros_S = S
      
C~~~  > The coefficient matrices A and C are strictly lower triangular.
C     The lower triangular (subdiagonal) elements are stored in row-wise order:
C     A(2,1) = ros_A(1), A(3,1)=ros_A(2), A(3,2)=ros_A(3), etc.
C     The general mapping formula is:
C     A(i,j) = ros_A( (i-1)*(i-2)/2 + j )    
C     C(i,j) = ros_C( (i-1)*(i-2)/2 + j )  
      
      ros_A(1) = 0.2000000000000000d+01
      ros_A(2) = 0.1867943637803922d+01
      ros_A(3) = 0.2344449711399156d+00
      ros_A(4) = ros_A(2)
      ros_A(5) = ros_A(3)
      ros_A(6) = 0.0D0

      ros_C(1) =-0.7137615036412310d+01
      ros_C(2) = 0.2580708087951457d+01
      ros_C(3) = 0.6515950076447975d+00
      ros_C(4) =-0.2137148994382534d+01
      ros_C(5) =-0.3214669691237626d+00
      ros_C(6) =-0.6949742501781779d+00
C~~~  > Does the stage i require a new function evaluation (ros_NewF(i)=TRUE)
C     or does it re-use the function evaluation from stage i-1 (ros_NewF(i)=FALSE)
      ros_NewF(1)  = .TRUE.
      ros_NewF(2)  = .TRUE.
      ros_NewF(3)  = .TRUE.
      ros_NewF(4)  = .FALSE.
C~~~  > M_i = Coefficients for new step solution
      ros_M(1) = 0.2255570073418735d+01
      ros_M(2) = 0.2870493262186792d+00
      ros_M(3) = 0.4353179431840180d+00
      ros_M(4) = 0.1093502252409163d+01
C~~~  > E_i  = Coefficients for error estimator    
      ros_E(1) =-0.2815431932141155d+00
      ros_E(2) =-0.7276199124938920d-01
      ros_E(3) =-0.1082196201495311d+00
      ros_E(4) =-0.1093502252409163d+01
C~~~  > ros_ELO  = estimator of local order - the minimum between the
C     main and the embedded scheme orders plus 1
      ros_ELO  = 4.0d0    
C~~~  > Y_stage_i ~ Y( T + H*Alpha_i )
      ros_Alpha(1) = 0.D0
      ros_Alpha(2) = 0.1145640000000000d+01
      ros_Alpha(3) = 0.6552168638155900d+00
      ros_Alpha(4) = ros_Alpha(3)
C~~~  > Gamma_i = \sum_j  gamma_{i,j}    
      ros_Gamma(1) = 0.5728200000000000d+00
      ros_Gamma(2) =-0.1769193891319233d+01
      ros_Gamma(3) = 0.7592633437920482d+00
      ros_Gamma(4) =-0.1049021087100450d+00

      END SUBROUTINE Ros4
      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE Rodas3 (ros_S,ros_A,ros_C,ros_M,ros_E,ros_Alpha, 
     &     ros_Gamma,ros_NewF,ros_ELO,ros_Name)
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     --- A STIFFLY-STABLE METHOD, 4 stages, order 3
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      IMPLICIT NONE
      
      INTEGER, PARAMETER :: S=4
      INTEGER, INTENT(OUT) ::  ros_S
      REAL(kind=dp), DIMENSION(S), INTENT(OUT) :: ros_M,ros_E,ros_Alpha,ros_Gamma
      REAL(kind=dp), DIMENSION(S*(S-1)/2), INTENT(OUT) :: ros_A, ros_C
      REAL(kind=dp), INTENT(OUT) :: ros_ELO
      LOGICAL, DIMENSION(S), INTENT(OUT) :: ros_NewF
      CHARACTER(LEN=12), INTENT(OUT) :: ros_Name
      DOUBLE PRECISION g
      
C~~~  > Name of the method
      ros_Name = 'RODAS-3'   
C~~~  > Number of stages
      ros_S = S
      
C~~~  > The coefficient matrices A and C are strictly lower triangular.
C     The lower triangular (subdiagonal) elements are stored in row-wise order:
C     A(2,1) = ros_A(1), A(3,1)=ros_A(2), A(3,2)=ros_A(3), etc.
C     The general mapping formula is:
C     A(i,j) = ros_A( (i-1)*(i-2)/2 + j )    
C     C(i,j) = ros_C( (i-1)*(i-2)/2 + j )  
      
      ros_A(1) = 0.0d+00
      ros_A(2) = 2.0d+00
      ros_A(3) = 0.0d+00
      ros_A(4) = 2.0d+00
      ros_A(5) = 0.0d+00
      ros_A(6) = 1.0d+00

      ros_C(1) = 4.0d+00
      ros_C(2) = 1.0d+00
      ros_C(3) =-1.0d+00
      ros_C(4) = 1.0d+00
      ros_C(5) =-1.0d+00 
      ros_C(6) =-(8.0d+00/3.0d+00) 
      
C~~~  > Does the stage i require a new function evaluation (ros_NewF(i)=TRUE)
C     or does it re-use the function evaluation from stage i-1 (ros_NewF(i)=FALSE)
      ros_NewF(1)  = .TRUE.
      ros_NewF(2)  = .FALSE.
      ros_NewF(3)  = .TRUE.
      ros_NewF(4)  = .TRUE.
C~~~  > M_i = Coefficients for new step solution
      ros_M(1) = 2.0d+00
      ros_M(2) = 0.0d+00
      ros_M(3) = 1.0d+00
      ros_M(4) = 1.0d+00
C~~~  > E_i  = Coefficients for error estimator    
      ros_E(1) = 0.0d+00
      ros_E(2) = 0.0d+00
      ros_E(3) = 0.0d+00
      ros_E(4) = 1.0d+00
C~~~  > ros_ELO  = estimator of local order - the minimum between the
C     main and the embedded scheme orders plus 1
      ros_ELO  = 3.0d+00    
C~~~  > Y_stage_i ~ Y( T + H*Alpha_i )
      ros_Alpha(1) = 0.0d+00
      ros_Alpha(2) = 0.0d+00
      ros_Alpha(3) = 1.0d+00
      ros_Alpha(4) = 1.0d+00
C~~~  > Gamma_i = \sum_j  gamma_{i,j}    
      ros_Gamma(1) = 0.5d+00
      ros_Gamma(2) = 1.5d+00
      ros_Gamma(3) = 0.0d+00
      ros_Gamma(4) = 0.0d+00

      END SUBROUTINE Rodas3
      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE Rodas4 (ros_S,ros_A,ros_C,ros_M,ros_E,ros_Alpha, 
     &     ros_Gamma,ros_NewF,ros_ELO,ros_Name)
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     STIFFLY-STABLE ROSENBROCK METHOD OF ORDER 4, WITH 6 STAGES
C     
C     E. HAIRER AND G. WANNER, SOLVING ORDINARY DIFFERENTIAL
C     EQUATIONS II. STIFF AND DIFFERENTIAL-ALGEBRAIC PROBLEMS.
C     SPRINGER SERIES IN COMPUTATIONAL MATHEMATICS,
C     SPRINGER-VERLAG (1996)         
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      IMPLICIT NONE
      
      INTEGER, PARAMETER :: S=6
      INTEGER, INTENT(OUT) ::  ros_S
      REAL(kind=dp), DIMENSION(S), INTENT(OUT) :: ros_M,ros_E,ros_Alpha,ros_Gamma
      REAL(kind=dp), DIMENSION(S*(S-1)/2), INTENT(OUT) :: ros_A, ros_C
      REAL(kind=dp), INTENT(OUT) :: ros_ELO
      LOGICAL, DIMENSION(S), INTENT(OUT) :: ros_NewF
      CHARACTER(LEN=12), INTENT(OUT) :: ros_Name
      DOUBLE PRECISION g

C~~~  > Name of the method
      ros_Name = 'RODAS-4'   
C~~~  > Number of stages
      ros_S = S

C~~~  > Y_stage_i ~ Y( T + H*Alpha_i )
      ros_Alpha(1) = 0.000d0
      ros_Alpha(2) = 0.386d0
      ros_Alpha(3) = 0.210d0 
      ros_Alpha(4) = 0.630d0
      ros_Alpha(5) = 1.000d0
      ros_Alpha(6) = 1.000d0
      
C~~~  > Gamma_i = \sum_j  gamma_{i,j}    
      ros_Gamma(1) = 0.2500000000000000d+00
      ros_Gamma(2) =-0.1043000000000000d+00
      ros_Gamma(3) = 0.1035000000000000d+00
      ros_Gamma(4) =-0.3620000000000023d-01
      ros_Gamma(5) = 0.0d0
      ros_Gamma(6) = 0.0d0

C~~~  > The coefficient matrices A and C are strictly lower triangular.
C     The lower triangular (subdiagonal) elements are stored in row-wise order:
C     A(2,1) = ros_A(1), A(3,1)=ros_A(2), A(3,2)=ros_A(3), etc.
C     The general mapping formula is:  A(i,j) = ros_A( (i-1)*(i-2)/2 + j )    
C     C(i,j) = ros_C( (i-1)*(i-2)/2 + j )  
      
      ros_A(1) = 0.1544000000000000d+01
      ros_A(2) = 0.9466785280815826d+00
      ros_A(3) = 0.2557011698983284d+00
      ros_A(4) = 0.3314825187068521d+01
      ros_A(5) = 0.2896124015972201d+01
      ros_A(6) = 0.9986419139977817d+00
      ros_A(7) = 0.1221224509226641d+01
      ros_A(8) = 0.6019134481288629d+01
      ros_A(9) = 0.1253708332932087d+02
      ros_A(10) =-0.6878860361058950d+00
      ros_A(11) = ros_A(7)
      ros_A(12) = ros_A(8)
      ros_A(13) = ros_A(9)
      ros_A(14) = ros_A(10)
      ros_A(15) = 1.0d+00

      ros_C(1) =-0.5668800000000000d+01
      ros_C(2) =-0.2430093356833875d+01
      ros_C(3) =-0.2063599157091915d+00
      ros_C(4) =-0.1073529058151375d+00
      ros_C(5) =-0.9594562251023355d+01
      ros_C(6) =-0.2047028614809616d+02
      ros_C(7) = 0.7496443313967647d+01
      ros_C(8) =-0.1024680431464352d+02
      ros_C(9) =-0.3399990352819905d+02
      ros_C(10) = 0.1170890893206160d+02
      ros_C(11) = 0.8083246795921522d+01
      ros_C(12) =-0.7981132988064893d+01
      ros_C(13) =-0.3152159432874371d+02
      ros_C(14) = 0.1631930543123136d+02
      ros_C(15) =-0.6058818238834054d+01

C~~~  > M_i = Coefficients for new step solution
      ros_M(1) = ros_A(7)
      ros_M(2) = ros_A(8)
      ros_M(3) = ros_A(9)
      ros_M(4) = ros_A(10)
      ros_M(5) = 1.0d+00
      ros_M(6) = 1.0d+00

C~~~  > E_i  = Coefficients for error estimator    
      ros_E(1) = 0.0d+00
      ros_E(2) = 0.0d+00
      ros_E(3) = 0.0d+00
      ros_E(4) = 0.0d+00
      ros_E(5) = 0.0d+00
      ros_E(6) = 1.0d+00

C~~~  > Does the stage i require a new function evaluation (ros_NewF(i)=TRUE)
C     or does it re-use the function evaluation from stage i-1 (ros_NewF(i)=FALSE)
      ros_NewF(1) = .TRUE.
      ros_NewF(2) = .TRUE.
      ros_NewF(3) = .TRUE.
      ros_NewF(4) = .TRUE.
      ros_NewF(5) = .TRUE.
      ros_NewF(6) = .TRUE.
      
C~~~  > ros_ELO  = estimator of local order - the minimum between the
C     main and the embedded scheme orders plus 1
      ros_ELO = 4.0d0
      
      END SUBROUTINE Rodas4

      

C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE FunTemplate( Y, RKI, Ydot )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     Template for the ODE function call.
C     Updates the rate coefficients (and possibly the fixed species) at each call    
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
C~~~  > Input variables     
      REAL(kind=dp) T, Y(KPPNSP), RKI(KPPNRCT)
C~~~  > Output variables     
      REAL(kind=dp) Ydot(KPPNSP)

      CALL Fun( Y, RKI, Ydot )
      
      Nfun = Nfun+1
      
      END SUBROUTINE FunTemplate

      
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE JacTemplate( Y, RKI, Jcb )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     Template for the ODE Jacobian call.
C     Updates the rate coefficients (and possibly the fixed species) at each call    
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C~~~  > Input variables     
      REAL(kind=dp) T, Y(KPPNSP), RKI(KPPNRCT)
C~~~  > Output variables     
      REAL(kind=dp) Jcb(LU_NONZERO)

      CALL Jac_SP( Y, RKI, Jcb )
      
      Njac = Njac+1

      END SUBROUTINE JacTemplate                                      


C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE HessTemplate( Y, RKI, Hes )
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C     Template for the ODE Hessian call.
C     Updates the rate coefficients (and possibly the fixed species) at each call    
C~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C~~~  > Input variables     
      REAL(kind=dp) T, Y(KPPNSP), RKI(KPPNRCT)
C~~~  > Output variables     
      REAL(kind=dp) Hes(NHESS)

      CALL Hessian( Y, RKI, Hes )

      END SUBROUTINE HessTemplate                                      

      END MODULE KPP_Integrator_adj

C     End of INTEGRATE function
C     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

